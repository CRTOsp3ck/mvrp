// Code generated by SQLBoiler 4.16.2 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package base

import (
	"bytes"
	"database/sql/driver"
	"encoding/json"
	"strconv"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/null/v8/convert"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/strmangle"
)

// M type is for providing columns and column values to UpdateAll.
type M map[string]interface{}

// ErrSyncFail occurs during insert when the record could not be retrieved in
// order to populate default value information. This usually happens when LastInsertId
// fails or there was a primary key configuration that was not resolvable.
var ErrSyncFail = errors.New("base: failed to synchronize data after insert")

type insertCache struct {
	query        string
	retQuery     string
	valueMapping []uint64
	retMapping   []uint64
}

type updateCache struct {
	query        string
	valueMapping []uint64
}

func makeCacheKey(cols boil.Columns, nzDefaults []string) string {
	buf := strmangle.GetBuffer()

	buf.WriteString(strconv.Itoa(cols.Kind))
	for _, w := range cols.Cols {
		buf.WriteString(w)
	}

	if len(nzDefaults) != 0 {
		buf.WriteByte('.')
	}
	for _, nz := range nzDefaults {
		buf.WriteString(nz)
	}

	str := buf.String()
	strmangle.PutBuffer(buf)
	return str
}

type ShippingTerms string

// Enum values for ShippingTerms
const (
	ShippingTermsFreeOnBoard             ShippingTerms = "free_on_board"
	ShippingTermsCostInsuranceAndFreight ShippingTerms = "cost_insurance_and_freight"
	ShippingTermsExWorks                 ShippingTerms = "ex_works"
	ShippingTermsDeliveredDutyPaid       ShippingTerms = "delivered_duty_paid"
	ShippingTermsDeliveredAtPlace        ShippingTerms = "delivered_at_place"
	ShippingTermsFreeCarrier             ShippingTerms = "free_carrier"
	ShippingTermsCarriagePaidTo          ShippingTerms = "carriage_paid_to"
)

func AllShippingTerms() []ShippingTerms {
	return []ShippingTerms{
		ShippingTermsFreeOnBoard,
		ShippingTermsCostInsuranceAndFreight,
		ShippingTermsExWorks,
		ShippingTermsDeliveredDutyPaid,
		ShippingTermsDeliveredAtPlace,
		ShippingTermsFreeCarrier,
		ShippingTermsCarriagePaidTo,
	}
}

func (e ShippingTerms) IsValid() error {
	switch e {
	case ShippingTermsFreeOnBoard, ShippingTermsCostInsuranceAndFreight, ShippingTermsExWorks, ShippingTermsDeliveredDutyPaid, ShippingTermsDeliveredAtPlace, ShippingTermsFreeCarrier, ShippingTermsCarriagePaidTo:
		return nil
	default:
		return errors.New("enum is not valid")
	}
}

func (e ShippingTerms) String() string {
	return string(e)
}

func (e ShippingTerms) Ordinal() int {
	switch e {
	case ShippingTermsFreeOnBoard:
		return 0
	case ShippingTermsCostInsuranceAndFreight:
		return 1
	case ShippingTermsExWorks:
		return 2
	case ShippingTermsDeliveredDutyPaid:
		return 3
	case ShippingTermsDeliveredAtPlace:
		return 4
	case ShippingTermsFreeCarrier:
		return 5
	case ShippingTermsCarriagePaidTo:
		return 6

	default:
		panic(errors.New("enum is not valid"))
	}
}

// NullShippingTerms is a nullable ShippingTerms enum type. It supports SQL and JSON serialization.
type NullShippingTerms struct {
	Val   ShippingTerms
	Valid bool
}

// NullShippingTermsFrom creates a new ShippingTerms that will never be blank.
func NullShippingTermsFrom(v ShippingTerms) NullShippingTerms {
	return NewNullShippingTerms(v, true)
}

// NullShippingTermsFromPtr creates a new NullShippingTerms that be null if s is nil.
func NullShippingTermsFromPtr(v *ShippingTerms) NullShippingTerms {
	if v == nil {
		return NewNullShippingTerms("", false)
	}
	return NewNullShippingTerms(*v, true)
}

// NewNullShippingTerms creates a new NullShippingTerms
func NewNullShippingTerms(v ShippingTerms, valid bool) NullShippingTerms {
	return NullShippingTerms{
		Val:   v,
		Valid: valid,
	}
}

// UnmarshalJSON implements json.Unmarshaler.
func (e *NullShippingTerms) UnmarshalJSON(data []byte) error {
	if bytes.Equal(data, null.NullBytes) {
		e.Val = ""
		e.Valid = false
		return nil
	}

	if err := json.Unmarshal(data, &e.Val); err != nil {
		return err
	}

	e.Valid = true
	return nil
}

// MarshalJSON implements json.Marshaler.
func (e NullShippingTerms) MarshalJSON() ([]byte, error) {
	if !e.Valid {
		return null.NullBytes, nil
	}
	return json.Marshal(e.Val)
}

// MarshalText implements encoding.TextMarshaler.
func (e NullShippingTerms) MarshalText() ([]byte, error) {
	if !e.Valid {
		return []byte{}, nil
	}
	return []byte(e.Val), nil
}

// UnmarshalText implements encoding.TextUnmarshaler.
func (e *NullShippingTerms) UnmarshalText(text []byte) error {
	if text == nil || len(text) == 0 {
		e.Valid = false
		return nil
	}

	e.Val = ShippingTerms(text)
	e.Valid = true
	return nil
}

// SetValid changes this NullShippingTerms value and also sets it to be non-null.
func (e *NullShippingTerms) SetValid(v ShippingTerms) {
	e.Val = v
	e.Valid = true
}

// Ptr returns a pointer to this NullShippingTerms value, or a nil pointer if this NullShippingTerms is null.
func (e NullShippingTerms) Ptr() *ShippingTerms {
	if !e.Valid {
		return nil
	}
	return &e.Val
}

// IsZero returns true for null types.
func (e NullShippingTerms) IsZero() bool {
	return !e.Valid
}

// Scan implements the Scanner interface.
func (e *NullShippingTerms) Scan(value interface{}) error {
	if value == nil {
		e.Val, e.Valid = "", false
		return nil
	}
	e.Valid = true
	return convert.ConvertAssign((*string)(&e.Val), value)
}

// Value implements the driver Valuer interface.
func (e NullShippingTerms) Value() (driver.Value, error) {
	if !e.Valid {
		return nil, nil
	}
	return string(e.Val), nil
}

type ShippingMethod string

// Enum values for ShippingMethod
const (
	ShippingMethodAirFreight     ShippingMethod = "air_freight"
	ShippingMethodSeaFreight     ShippingMethod = "sea_freight"
	ShippingMethodGroundShipping ShippingMethod = "ground_shipping"
	ShippingMethodCourierService ShippingMethod = "courier_service"
	ShippingMethodRailFreight    ShippingMethod = "rail_freight"
	ShippingMethodMultimodal     ShippingMethod = "multimodal"
	ShippingMethodDropShipping   ShippingMethod = "drop_shipping"
	ShippingMethod3PL            ShippingMethod = "3pl"
	ShippingMethodExpedited      ShippingMethod = "expedited"
	ShippingMethodStandard       ShippingMethod = "standard"
	ShippingMethodSameDay        ShippingMethod = "same_day"
	ShippingMethodNextDay        ShippingMethod = "next_day"
	ShippingMethodEconomy        ShippingMethod = "economy"
)

func AllShippingMethod() []ShippingMethod {
	return []ShippingMethod{
		ShippingMethodAirFreight,
		ShippingMethodSeaFreight,
		ShippingMethodGroundShipping,
		ShippingMethodCourierService,
		ShippingMethodRailFreight,
		ShippingMethodMultimodal,
		ShippingMethodDropShipping,
		ShippingMethod3PL,
		ShippingMethodExpedited,
		ShippingMethodStandard,
		ShippingMethodSameDay,
		ShippingMethodNextDay,
		ShippingMethodEconomy,
	}
}

func (e ShippingMethod) IsValid() error {
	switch e {
	case ShippingMethodAirFreight, ShippingMethodSeaFreight, ShippingMethodGroundShipping, ShippingMethodCourierService, ShippingMethodRailFreight, ShippingMethodMultimodal, ShippingMethodDropShipping, ShippingMethod3PL, ShippingMethodExpedited, ShippingMethodStandard, ShippingMethodSameDay, ShippingMethodNextDay, ShippingMethodEconomy:
		return nil
	default:
		return errors.New("enum is not valid")
	}
}

func (e ShippingMethod) String() string {
	return string(e)
}

func (e ShippingMethod) Ordinal() int {
	switch e {
	case ShippingMethodAirFreight:
		return 0
	case ShippingMethodSeaFreight:
		return 1
	case ShippingMethodGroundShipping:
		return 2
	case ShippingMethodCourierService:
		return 3
	case ShippingMethodRailFreight:
		return 4
	case ShippingMethodMultimodal:
		return 5
	case ShippingMethodDropShipping:
		return 6
	case ShippingMethod3PL:
		return 7
	case ShippingMethodExpedited:
		return 8
	case ShippingMethodStandard:
		return 9
	case ShippingMethodSameDay:
		return 10
	case ShippingMethodNextDay:
		return 11
	case ShippingMethodEconomy:
		return 12

	default:
		panic(errors.New("enum is not valid"))
	}
}

// NullShippingMethod is a nullable ShippingMethod enum type. It supports SQL and JSON serialization.
type NullShippingMethod struct {
	Val   ShippingMethod
	Valid bool
}

// NullShippingMethodFrom creates a new ShippingMethod that will never be blank.
func NullShippingMethodFrom(v ShippingMethod) NullShippingMethod {
	return NewNullShippingMethod(v, true)
}

// NullShippingMethodFromPtr creates a new NullShippingMethod that be null if s is nil.
func NullShippingMethodFromPtr(v *ShippingMethod) NullShippingMethod {
	if v == nil {
		return NewNullShippingMethod("", false)
	}
	return NewNullShippingMethod(*v, true)
}

// NewNullShippingMethod creates a new NullShippingMethod
func NewNullShippingMethod(v ShippingMethod, valid bool) NullShippingMethod {
	return NullShippingMethod{
		Val:   v,
		Valid: valid,
	}
}

// UnmarshalJSON implements json.Unmarshaler.
func (e *NullShippingMethod) UnmarshalJSON(data []byte) error {
	if bytes.Equal(data, null.NullBytes) {
		e.Val = ""
		e.Valid = false
		return nil
	}

	if err := json.Unmarshal(data, &e.Val); err != nil {
		return err
	}

	e.Valid = true
	return nil
}

// MarshalJSON implements json.Marshaler.
func (e NullShippingMethod) MarshalJSON() ([]byte, error) {
	if !e.Valid {
		return null.NullBytes, nil
	}
	return json.Marshal(e.Val)
}

// MarshalText implements encoding.TextMarshaler.
func (e NullShippingMethod) MarshalText() ([]byte, error) {
	if !e.Valid {
		return []byte{}, nil
	}
	return []byte(e.Val), nil
}

// UnmarshalText implements encoding.TextUnmarshaler.
func (e *NullShippingMethod) UnmarshalText(text []byte) error {
	if text == nil || len(text) == 0 {
		e.Valid = false
		return nil
	}

	e.Val = ShippingMethod(text)
	e.Valid = true
	return nil
}

// SetValid changes this NullShippingMethod value and also sets it to be non-null.
func (e *NullShippingMethod) SetValid(v ShippingMethod) {
	e.Val = v
	e.Valid = true
}

// Ptr returns a pointer to this NullShippingMethod value, or a nil pointer if this NullShippingMethod is null.
func (e NullShippingMethod) Ptr() *ShippingMethod {
	if !e.Valid {
		return nil
	}
	return &e.Val
}

// IsZero returns true for null types.
func (e NullShippingMethod) IsZero() bool {
	return !e.Valid
}

// Scan implements the Scanner interface.
func (e *NullShippingMethod) Scan(value interface{}) error {
	if value == nil {
		e.Val, e.Valid = "", false
		return nil
	}
	e.Valid = true
	return convert.ConvertAssign((*string)(&e.Val), value)
}

// Value implements the driver Valuer interface.
func (e NullShippingMethod) Value() (driver.Value, error) {
	if !e.Valid {
		return nil, nil
	}
	return string(e.Val), nil
}

type PaymentTerms string

// Enum values for PaymentTerms
const (
	PaymentTermsFull                          PaymentTerms = "full"
	PaymentTermsPartialBeforeAndAfterDelivery PaymentTerms = "partial_before_and_after_delivery"
	PaymentTermsNet30                         PaymentTerms = "net_30"
	PaymentTermsNet60                         PaymentTerms = "net_60"
	PaymentTermsNet90                         PaymentTerms = "net_90"
)

func AllPaymentTerms() []PaymentTerms {
	return []PaymentTerms{
		PaymentTermsFull,
		PaymentTermsPartialBeforeAndAfterDelivery,
		PaymentTermsNet30,
		PaymentTermsNet60,
		PaymentTermsNet90,
	}
}

func (e PaymentTerms) IsValid() error {
	switch e {
	case PaymentTermsFull, PaymentTermsPartialBeforeAndAfterDelivery, PaymentTermsNet30, PaymentTermsNet60, PaymentTermsNet90:
		return nil
	default:
		return errors.New("enum is not valid")
	}
}

func (e PaymentTerms) String() string {
	return string(e)
}

func (e PaymentTerms) Ordinal() int {
	switch e {
	case PaymentTermsFull:
		return 0
	case PaymentTermsPartialBeforeAndAfterDelivery:
		return 1
	case PaymentTermsNet30:
		return 2
	case PaymentTermsNet60:
		return 3
	case PaymentTermsNet90:
		return 4

	default:
		panic(errors.New("enum is not valid"))
	}
}

// NullPaymentTerms is a nullable PaymentTerms enum type. It supports SQL and JSON serialization.
type NullPaymentTerms struct {
	Val   PaymentTerms
	Valid bool
}

// NullPaymentTermsFrom creates a new PaymentTerms that will never be blank.
func NullPaymentTermsFrom(v PaymentTerms) NullPaymentTerms {
	return NewNullPaymentTerms(v, true)
}

// NullPaymentTermsFromPtr creates a new NullPaymentTerms that be null if s is nil.
func NullPaymentTermsFromPtr(v *PaymentTerms) NullPaymentTerms {
	if v == nil {
		return NewNullPaymentTerms("", false)
	}
	return NewNullPaymentTerms(*v, true)
}

// NewNullPaymentTerms creates a new NullPaymentTerms
func NewNullPaymentTerms(v PaymentTerms, valid bool) NullPaymentTerms {
	return NullPaymentTerms{
		Val:   v,
		Valid: valid,
	}
}

// UnmarshalJSON implements json.Unmarshaler.
func (e *NullPaymentTerms) UnmarshalJSON(data []byte) error {
	if bytes.Equal(data, null.NullBytes) {
		e.Val = ""
		e.Valid = false
		return nil
	}

	if err := json.Unmarshal(data, &e.Val); err != nil {
		return err
	}

	e.Valid = true
	return nil
}

// MarshalJSON implements json.Marshaler.
func (e NullPaymentTerms) MarshalJSON() ([]byte, error) {
	if !e.Valid {
		return null.NullBytes, nil
	}
	return json.Marshal(e.Val)
}

// MarshalText implements encoding.TextMarshaler.
func (e NullPaymentTerms) MarshalText() ([]byte, error) {
	if !e.Valid {
		return []byte{}, nil
	}
	return []byte(e.Val), nil
}

// UnmarshalText implements encoding.TextUnmarshaler.
func (e *NullPaymentTerms) UnmarshalText(text []byte) error {
	if text == nil || len(text) == 0 {
		e.Valid = false
		return nil
	}

	e.Val = PaymentTerms(text)
	e.Valid = true
	return nil
}

// SetValid changes this NullPaymentTerms value and also sets it to be non-null.
func (e *NullPaymentTerms) SetValid(v PaymentTerms) {
	e.Val = v
	e.Valid = true
}

// Ptr returns a pointer to this NullPaymentTerms value, or a nil pointer if this NullPaymentTerms is null.
func (e NullPaymentTerms) Ptr() *PaymentTerms {
	if !e.Valid {
		return nil
	}
	return &e.Val
}

// IsZero returns true for null types.
func (e NullPaymentTerms) IsZero() bool {
	return !e.Valid
}

// Scan implements the Scanner interface.
func (e *NullPaymentTerms) Scan(value interface{}) error {
	if value == nil {
		e.Val, e.Valid = "", false
		return nil
	}
	e.Valid = true
	return convert.ConvertAssign((*string)(&e.Val), value)
}

// Value implements the driver Valuer interface.
func (e NullPaymentTerms) Value() (driver.Value, error) {
	if !e.Valid {
		return nil, nil
	}
	return string(e.Val), nil
}

type PaymentStatus string

// Enum values for PaymentStatus
const (
	PaymentStatusPending       PaymentStatus = "pending"
	PaymentStatusPaid          PaymentStatus = "paid"
	PaymentStatusPartiallyPaid PaymentStatus = "partially_paid"
)

func AllPaymentStatus() []PaymentStatus {
	return []PaymentStatus{
		PaymentStatusPending,
		PaymentStatusPaid,
		PaymentStatusPartiallyPaid,
	}
}

func (e PaymentStatus) IsValid() error {
	switch e {
	case PaymentStatusPending, PaymentStatusPaid, PaymentStatusPartiallyPaid:
		return nil
	default:
		return errors.New("enum is not valid")
	}
}

func (e PaymentStatus) String() string {
	return string(e)
}

func (e PaymentStatus) Ordinal() int {
	switch e {
	case PaymentStatusPending:
		return 0
	case PaymentStatusPaid:
		return 1
	case PaymentStatusPartiallyPaid:
		return 2

	default:
		panic(errors.New("enum is not valid"))
	}
}

// NullPaymentStatus is a nullable PaymentStatus enum type. It supports SQL and JSON serialization.
type NullPaymentStatus struct {
	Val   PaymentStatus
	Valid bool
}

// NullPaymentStatusFrom creates a new PaymentStatus that will never be blank.
func NullPaymentStatusFrom(v PaymentStatus) NullPaymentStatus {
	return NewNullPaymentStatus(v, true)
}

// NullPaymentStatusFromPtr creates a new NullPaymentStatus that be null if s is nil.
func NullPaymentStatusFromPtr(v *PaymentStatus) NullPaymentStatus {
	if v == nil {
		return NewNullPaymentStatus("", false)
	}
	return NewNullPaymentStatus(*v, true)
}

// NewNullPaymentStatus creates a new NullPaymentStatus
func NewNullPaymentStatus(v PaymentStatus, valid bool) NullPaymentStatus {
	return NullPaymentStatus{
		Val:   v,
		Valid: valid,
	}
}

// UnmarshalJSON implements json.Unmarshaler.
func (e *NullPaymentStatus) UnmarshalJSON(data []byte) error {
	if bytes.Equal(data, null.NullBytes) {
		e.Val = ""
		e.Valid = false
		return nil
	}

	if err := json.Unmarshal(data, &e.Val); err != nil {
		return err
	}

	e.Valid = true
	return nil
}

// MarshalJSON implements json.Marshaler.
func (e NullPaymentStatus) MarshalJSON() ([]byte, error) {
	if !e.Valid {
		return null.NullBytes, nil
	}
	return json.Marshal(e.Val)
}

// MarshalText implements encoding.TextMarshaler.
func (e NullPaymentStatus) MarshalText() ([]byte, error) {
	if !e.Valid {
		return []byte{}, nil
	}
	return []byte(e.Val), nil
}

// UnmarshalText implements encoding.TextUnmarshaler.
func (e *NullPaymentStatus) UnmarshalText(text []byte) error {
	if text == nil || len(text) == 0 {
		e.Valid = false
		return nil
	}

	e.Val = PaymentStatus(text)
	e.Valid = true
	return nil
}

// SetValid changes this NullPaymentStatus value and also sets it to be non-null.
func (e *NullPaymentStatus) SetValid(v PaymentStatus) {
	e.Val = v
	e.Valid = true
}

// Ptr returns a pointer to this NullPaymentStatus value, or a nil pointer if this NullPaymentStatus is null.
func (e NullPaymentStatus) Ptr() *PaymentStatus {
	if !e.Valid {
		return nil
	}
	return &e.Val
}

// IsZero returns true for null types.
func (e NullPaymentStatus) IsZero() bool {
	return !e.Valid
}

// Scan implements the Scanner interface.
func (e *NullPaymentStatus) Scan(value interface{}) error {
	if value == nil {
		e.Val, e.Valid = "", false
		return nil
	}
	e.Valid = true
	return convert.ConvertAssign((*string)(&e.Val), value)
}

// Value implements the driver Valuer interface.
func (e NullPaymentStatus) Value() (driver.Value, error) {
	if !e.Valid {
		return nil, nil
	}
	return string(e.Val), nil
}
