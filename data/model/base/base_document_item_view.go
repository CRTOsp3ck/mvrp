// Code generated by SQLBoiler 4.16.2 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package base

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/sqlboiler/v4/types"
	"github.com/volatiletech/strmangle"
)

// BaseDocumentItemView is an object representing the database table.
type BaseDocumentItemView struct {
	ID                     null.Int          `boil:"id" json:"id,omitempty" toml:"id" yaml:"id,omitempty"`
	CreatedAt              null.Time         `boil:"created_at" json:"created_at,omitempty" toml:"created_at" yaml:"created_at,omitempty"`
	UpdatedAt              null.Time         `boil:"updated_at" json:"updated_at,omitempty" toml:"updated_at" yaml:"updated_at,omitempty"`
	DeletedAt              null.Time         `boil:"deleted_at" json:"deleted_at,omitempty" toml:"deleted_at" yaml:"deleted_at,omitempty"`
	BaseDocumentID         null.Int          `boil:"base_document_id" json:"base_document_id,omitempty" toml:"base_document_id" yaml:"base_document_id,omitempty"`
	InventoryID            null.Int          `boil:"inventory_id" json:"inventory_id,omitempty" toml:"inventory_id" yaml:"inventory_id,omitempty"`
	Quantity               types.NullDecimal `boil:"quantity" json:"quantity,omitempty" toml:"quantity" yaml:"quantity,omitempty"`
	UnitPrice              types.NullDecimal `boil:"unit_price" json:"unit_price,omitempty" toml:"unit_price" yaml:"unit_price,omitempty"`
	UnitDiscountAmount     types.NullDecimal `boil:"unit_discount_amount" json:"unit_discount_amount,omitempty" toml:"unit_discount_amount" yaml:"unit_discount_amount,omitempty"`
	TotalDiscountAmountGen types.NullDecimal `boil:"total_discount_amount_gen" json:"total_discount_amount_gen,omitempty" toml:"total_discount_amount_gen" yaml:"total_discount_amount_gen,omitempty"`
	DiscountRateGen        types.NullDecimal `boil:"discount_rate_gen" json:"discount_rate_gen,omitempty" toml:"discount_rate_gen" yaml:"discount_rate_gen,omitempty"`
	UnitTaxAmount          types.NullDecimal `boil:"unit_tax_amount" json:"unit_tax_amount,omitempty" toml:"unit_tax_amount" yaml:"unit_tax_amount,omitempty"`
	TotalTaxAmountGen      types.NullDecimal `boil:"total_tax_amount_gen" json:"total_tax_amount_gen,omitempty" toml:"total_tax_amount_gen" yaml:"total_tax_amount_gen,omitempty"`
	TaxRateGen             types.NullDecimal `boil:"tax_rate_gen" json:"tax_rate_gen,omitempty" toml:"tax_rate_gen" yaml:"tax_rate_gen,omitempty"`
	UnitShippingFees       types.NullDecimal `boil:"unit_shipping_fees" json:"unit_shipping_fees,omitempty" toml:"unit_shipping_fees" yaml:"unit_shipping_fees,omitempty"`
	TotalShippingFeesGen   types.NullDecimal `boil:"total_shipping_fees_gen" json:"total_shipping_fees_gen,omitempty" toml:"total_shipping_fees_gen" yaml:"total_shipping_fees_gen,omitempty"`
	FinalUnitPriceGen      types.NullDecimal `boil:"final_unit_price_gen" json:"final_unit_price_gen,omitempty" toml:"final_unit_price_gen" yaml:"final_unit_price_gen,omitempty"`
	TotalSalePriceGen      types.NullDecimal `boil:"total_sale_price_gen" json:"total_sale_price_gen,omitempty" toml:"total_sale_price_gen" yaml:"total_sale_price_gen,omitempty"`
	InventoryInfo          null.JSON         `boil:"inventory_info" json:"inventory_info,omitempty" toml:"inventory_info" yaml:"inventory_info,omitempty"`
}

var BaseDocumentItemViewColumns = struct {
	ID                     string
	CreatedAt              string
	UpdatedAt              string
	DeletedAt              string
	BaseDocumentID         string
	InventoryID            string
	Quantity               string
	UnitPrice              string
	UnitDiscountAmount     string
	TotalDiscountAmountGen string
	DiscountRateGen        string
	UnitTaxAmount          string
	TotalTaxAmountGen      string
	TaxRateGen             string
	UnitShippingFees       string
	TotalShippingFeesGen   string
	FinalUnitPriceGen      string
	TotalSalePriceGen      string
	InventoryInfo          string
}{
	ID:                     "id",
	CreatedAt:              "created_at",
	UpdatedAt:              "updated_at",
	DeletedAt:              "deleted_at",
	BaseDocumentID:         "base_document_id",
	InventoryID:            "inventory_id",
	Quantity:               "quantity",
	UnitPrice:              "unit_price",
	UnitDiscountAmount:     "unit_discount_amount",
	TotalDiscountAmountGen: "total_discount_amount_gen",
	DiscountRateGen:        "discount_rate_gen",
	UnitTaxAmount:          "unit_tax_amount",
	TotalTaxAmountGen:      "total_tax_amount_gen",
	TaxRateGen:             "tax_rate_gen",
	UnitShippingFees:       "unit_shipping_fees",
	TotalShippingFeesGen:   "total_shipping_fees_gen",
	FinalUnitPriceGen:      "final_unit_price_gen",
	TotalSalePriceGen:      "total_sale_price_gen",
	InventoryInfo:          "inventory_info",
}

var BaseDocumentItemViewTableColumns = struct {
	ID                     string
	CreatedAt              string
	UpdatedAt              string
	DeletedAt              string
	BaseDocumentID         string
	InventoryID            string
	Quantity               string
	UnitPrice              string
	UnitDiscountAmount     string
	TotalDiscountAmountGen string
	DiscountRateGen        string
	UnitTaxAmount          string
	TotalTaxAmountGen      string
	TaxRateGen             string
	UnitShippingFees       string
	TotalShippingFeesGen   string
	FinalUnitPriceGen      string
	TotalSalePriceGen      string
	InventoryInfo          string
}{
	ID:                     "base_document_item_view.id",
	CreatedAt:              "base_document_item_view.created_at",
	UpdatedAt:              "base_document_item_view.updated_at",
	DeletedAt:              "base_document_item_view.deleted_at",
	BaseDocumentID:         "base_document_item_view.base_document_id",
	InventoryID:            "base_document_item_view.inventory_id",
	Quantity:               "base_document_item_view.quantity",
	UnitPrice:              "base_document_item_view.unit_price",
	UnitDiscountAmount:     "base_document_item_view.unit_discount_amount",
	TotalDiscountAmountGen: "base_document_item_view.total_discount_amount_gen",
	DiscountRateGen:        "base_document_item_view.discount_rate_gen",
	UnitTaxAmount:          "base_document_item_view.unit_tax_amount",
	TotalTaxAmountGen:      "base_document_item_view.total_tax_amount_gen",
	TaxRateGen:             "base_document_item_view.tax_rate_gen",
	UnitShippingFees:       "base_document_item_view.unit_shipping_fees",
	TotalShippingFeesGen:   "base_document_item_view.total_shipping_fees_gen",
	FinalUnitPriceGen:      "base_document_item_view.final_unit_price_gen",
	TotalSalePriceGen:      "base_document_item_view.total_sale_price_gen",
	InventoryInfo:          "base_document_item_view.inventory_info",
}

// Generated where

type whereHelpernull_JSON struct{ field string }

func (w whereHelpernull_JSON) EQ(x null.JSON) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_JSON) NEQ(x null.JSON) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_JSON) LT(x null.JSON) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_JSON) LTE(x null.JSON) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_JSON) GT(x null.JSON) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_JSON) GTE(x null.JSON) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

func (w whereHelpernull_JSON) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_JSON) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }

var BaseDocumentItemViewWhere = struct {
	ID                     whereHelpernull_Int
	CreatedAt              whereHelpernull_Time
	UpdatedAt              whereHelpernull_Time
	DeletedAt              whereHelpernull_Time
	BaseDocumentID         whereHelpernull_Int
	InventoryID            whereHelpernull_Int
	Quantity               whereHelpertypes_NullDecimal
	UnitPrice              whereHelpertypes_NullDecimal
	UnitDiscountAmount     whereHelpertypes_NullDecimal
	TotalDiscountAmountGen whereHelpertypes_NullDecimal
	DiscountRateGen        whereHelpertypes_NullDecimal
	UnitTaxAmount          whereHelpertypes_NullDecimal
	TotalTaxAmountGen      whereHelpertypes_NullDecimal
	TaxRateGen             whereHelpertypes_NullDecimal
	UnitShippingFees       whereHelpertypes_NullDecimal
	TotalShippingFeesGen   whereHelpertypes_NullDecimal
	FinalUnitPriceGen      whereHelpertypes_NullDecimal
	TotalSalePriceGen      whereHelpertypes_NullDecimal
	InventoryInfo          whereHelpernull_JSON
}{
	ID:                     whereHelpernull_Int{field: "\"base\".\"base_document_item_view\".\"id\""},
	CreatedAt:              whereHelpernull_Time{field: "\"base\".\"base_document_item_view\".\"created_at\""},
	UpdatedAt:              whereHelpernull_Time{field: "\"base\".\"base_document_item_view\".\"updated_at\""},
	DeletedAt:              whereHelpernull_Time{field: "\"base\".\"base_document_item_view\".\"deleted_at\""},
	BaseDocumentID:         whereHelpernull_Int{field: "\"base\".\"base_document_item_view\".\"base_document_id\""},
	InventoryID:            whereHelpernull_Int{field: "\"base\".\"base_document_item_view\".\"inventory_id\""},
	Quantity:               whereHelpertypes_NullDecimal{field: "\"base\".\"base_document_item_view\".\"quantity\""},
	UnitPrice:              whereHelpertypes_NullDecimal{field: "\"base\".\"base_document_item_view\".\"unit_price\""},
	UnitDiscountAmount:     whereHelpertypes_NullDecimal{field: "\"base\".\"base_document_item_view\".\"unit_discount_amount\""},
	TotalDiscountAmountGen: whereHelpertypes_NullDecimal{field: "\"base\".\"base_document_item_view\".\"total_discount_amount_gen\""},
	DiscountRateGen:        whereHelpertypes_NullDecimal{field: "\"base\".\"base_document_item_view\".\"discount_rate_gen\""},
	UnitTaxAmount:          whereHelpertypes_NullDecimal{field: "\"base\".\"base_document_item_view\".\"unit_tax_amount\""},
	TotalTaxAmountGen:      whereHelpertypes_NullDecimal{field: "\"base\".\"base_document_item_view\".\"total_tax_amount_gen\""},
	TaxRateGen:             whereHelpertypes_NullDecimal{field: "\"base\".\"base_document_item_view\".\"tax_rate_gen\""},
	UnitShippingFees:       whereHelpertypes_NullDecimal{field: "\"base\".\"base_document_item_view\".\"unit_shipping_fees\""},
	TotalShippingFeesGen:   whereHelpertypes_NullDecimal{field: "\"base\".\"base_document_item_view\".\"total_shipping_fees_gen\""},
	FinalUnitPriceGen:      whereHelpertypes_NullDecimal{field: "\"base\".\"base_document_item_view\".\"final_unit_price_gen\""},
	TotalSalePriceGen:      whereHelpertypes_NullDecimal{field: "\"base\".\"base_document_item_view\".\"total_sale_price_gen\""},
	InventoryInfo:          whereHelpernull_JSON{field: "\"base\".\"base_document_item_view\".\"inventory_info\""},
}

var (
	baseDocumentItemViewAllColumns            = []string{"id", "created_at", "updated_at", "deleted_at", "base_document_id", "inventory_id", "quantity", "unit_price", "unit_discount_amount", "total_discount_amount_gen", "discount_rate_gen", "unit_tax_amount", "total_tax_amount_gen", "tax_rate_gen", "unit_shipping_fees", "total_shipping_fees_gen", "final_unit_price_gen", "total_sale_price_gen", "inventory_info"}
	baseDocumentItemViewColumnsWithoutDefault = []string{}
	baseDocumentItemViewColumnsWithDefault    = []string{"id", "created_at", "updated_at", "deleted_at", "base_document_id", "inventory_id", "quantity", "unit_price", "unit_discount_amount", "total_discount_amount_gen", "discount_rate_gen", "unit_tax_amount", "total_tax_amount_gen", "tax_rate_gen", "unit_shipping_fees", "total_shipping_fees_gen", "final_unit_price_gen", "total_sale_price_gen", "inventory_info"}
	baseDocumentItemViewPrimaryKeyColumns     = []string{}
	baseDocumentItemViewGeneratedColumns      = []string{}
)

type (
	// BaseDocumentItemViewSlice is an alias for a slice of pointers to BaseDocumentItemView.
	// This should almost always be used instead of []BaseDocumentItemView.
	BaseDocumentItemViewSlice []*BaseDocumentItemView
	// BaseDocumentItemViewHook is the signature for custom BaseDocumentItemView hook methods
	BaseDocumentItemViewHook func(context.Context, boil.ContextExecutor, *BaseDocumentItemView) error

	baseDocumentItemViewQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	baseDocumentItemViewType           = reflect.TypeOf(&BaseDocumentItemView{})
	baseDocumentItemViewMapping        = queries.MakeStructMapping(baseDocumentItemViewType)
	baseDocumentItemViewInsertCacheMut sync.RWMutex
	baseDocumentItemViewInsertCache    = make(map[string]insertCache)
	baseDocumentItemViewUpdateCacheMut sync.RWMutex
	baseDocumentItemViewUpdateCache    = make(map[string]updateCache)
	baseDocumentItemViewUpsertCacheMut sync.RWMutex
	baseDocumentItemViewUpsertCache    = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
	// These are used in some views
	_ = fmt.Sprintln("")
	_ = reflect.Int
	_ = strings.Builder{}
	_ = sync.Mutex{}
	_ = strmangle.Plural("")
	_ = strconv.IntSize
)

var baseDocumentItemViewAfterSelectMu sync.Mutex
var baseDocumentItemViewAfterSelectHooks []BaseDocumentItemViewHook

var baseDocumentItemViewBeforeInsertMu sync.Mutex
var baseDocumentItemViewBeforeInsertHooks []BaseDocumentItemViewHook
var baseDocumentItemViewAfterInsertMu sync.Mutex
var baseDocumentItemViewAfterInsertHooks []BaseDocumentItemViewHook

var baseDocumentItemViewBeforeUpsertMu sync.Mutex
var baseDocumentItemViewBeforeUpsertHooks []BaseDocumentItemViewHook
var baseDocumentItemViewAfterUpsertMu sync.Mutex
var baseDocumentItemViewAfterUpsertHooks []BaseDocumentItemViewHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *BaseDocumentItemView) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range baseDocumentItemViewAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *BaseDocumentItemView) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range baseDocumentItemViewBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *BaseDocumentItemView) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range baseDocumentItemViewAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *BaseDocumentItemView) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range baseDocumentItemViewBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *BaseDocumentItemView) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range baseDocumentItemViewAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddBaseDocumentItemViewHook registers your hook function for all future operations.
func AddBaseDocumentItemViewHook(hookPoint boil.HookPoint, baseDocumentItemViewHook BaseDocumentItemViewHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		baseDocumentItemViewAfterSelectMu.Lock()
		baseDocumentItemViewAfterSelectHooks = append(baseDocumentItemViewAfterSelectHooks, baseDocumentItemViewHook)
		baseDocumentItemViewAfterSelectMu.Unlock()
	case boil.BeforeInsertHook:
		baseDocumentItemViewBeforeInsertMu.Lock()
		baseDocumentItemViewBeforeInsertHooks = append(baseDocumentItemViewBeforeInsertHooks, baseDocumentItemViewHook)
		baseDocumentItemViewBeforeInsertMu.Unlock()
	case boil.AfterInsertHook:
		baseDocumentItemViewAfterInsertMu.Lock()
		baseDocumentItemViewAfterInsertHooks = append(baseDocumentItemViewAfterInsertHooks, baseDocumentItemViewHook)
		baseDocumentItemViewAfterInsertMu.Unlock()
	case boil.BeforeUpsertHook:
		baseDocumentItemViewBeforeUpsertMu.Lock()
		baseDocumentItemViewBeforeUpsertHooks = append(baseDocumentItemViewBeforeUpsertHooks, baseDocumentItemViewHook)
		baseDocumentItemViewBeforeUpsertMu.Unlock()
	case boil.AfterUpsertHook:
		baseDocumentItemViewAfterUpsertMu.Lock()
		baseDocumentItemViewAfterUpsertHooks = append(baseDocumentItemViewAfterUpsertHooks, baseDocumentItemViewHook)
		baseDocumentItemViewAfterUpsertMu.Unlock()
	}
}

// One returns a single baseDocumentItemView record from the query.
func (q baseDocumentItemViewQuery) One(ctx context.Context, exec boil.ContextExecutor) (*BaseDocumentItemView, error) {
	o := &BaseDocumentItemView{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "base: failed to execute a one query for base_document_item_view")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all BaseDocumentItemView records from the query.
func (q baseDocumentItemViewQuery) All(ctx context.Context, exec boil.ContextExecutor) (BaseDocumentItemViewSlice, error) {
	var o []*BaseDocumentItemView

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "base: failed to assign all query results to BaseDocumentItemView slice")
	}

	if len(baseDocumentItemViewAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all BaseDocumentItemView records in the query.
func (q baseDocumentItemViewQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "base: failed to count base_document_item_view rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q baseDocumentItemViewQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "base: failed to check if base_document_item_view exists")
	}

	return count > 0, nil
}

// BaseDocumentItemViews retrieves all the records using an executor.
func BaseDocumentItemViews(mods ...qm.QueryMod) baseDocumentItemViewQuery {
	mods = append(mods, qm.From("\"base\".\"base_document_item_view\""))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"\"base\".\"base_document_item_view\".*"})
	}

	return baseDocumentItemViewQuery{q}
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *BaseDocumentItemView) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("base: no base_document_item_view provided for insertion")
	}

	var err error
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if queries.MustTime(o.CreatedAt).IsZero() {
			queries.SetScanner(&o.CreatedAt, currTime)
		}
		if queries.MustTime(o.UpdatedAt).IsZero() {
			queries.SetScanner(&o.UpdatedAt, currTime)
		}
	}

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(baseDocumentItemViewColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	baseDocumentItemViewInsertCacheMut.RLock()
	cache, cached := baseDocumentItemViewInsertCache[key]
	baseDocumentItemViewInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			baseDocumentItemViewAllColumns,
			baseDocumentItemViewColumnsWithDefault,
			baseDocumentItemViewColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(baseDocumentItemViewType, baseDocumentItemViewMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(baseDocumentItemViewType, baseDocumentItemViewMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"base\".\"base_document_item_view\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"base\".\"base_document_item_view\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "base: unable to insert into base_document_item_view")
	}

	if !cached {
		baseDocumentItemViewInsertCacheMut.Lock()
		baseDocumentItemViewInsertCache[key] = cache
		baseDocumentItemViewInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *BaseDocumentItemView) Upsert(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns, opts ...UpsertOptionFunc) error {
	if o == nil {
		return errors.New("base: no base_document_item_view provided for upsert")
	}
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if queries.MustTime(o.CreatedAt).IsZero() {
			queries.SetScanner(&o.CreatedAt, currTime)
		}
		queries.SetScanner(&o.UpdatedAt, currTime)
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(baseDocumentItemViewColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	baseDocumentItemViewUpsertCacheMut.RLock()
	cache, cached := baseDocumentItemViewUpsertCache[key]
	baseDocumentItemViewUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, _ := insertColumns.InsertColumnSet(
			baseDocumentItemViewAllColumns,
			baseDocumentItemViewColumnsWithDefault,
			baseDocumentItemViewColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			baseDocumentItemViewAllColumns,
			baseDocumentItemViewPrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("base: unable to upsert base_document_item_view, could not build update column list")
		}

		ret := strmangle.SetComplement(baseDocumentItemViewAllColumns, strmangle.SetIntersect(insert, update))

		conflict := conflictColumns
		if len(conflict) == 0 && updateOnConflict && len(update) != 0 {
			if len(baseDocumentItemViewPrimaryKeyColumns) == 0 {
				return errors.New("base: unable to upsert base_document_item_view, could not build conflict column list")
			}

			conflict = make([]string, len(baseDocumentItemViewPrimaryKeyColumns))
			copy(conflict, baseDocumentItemViewPrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"base\".\"base_document_item_view\"", updateOnConflict, ret, update, conflict, insert, opts...)

		cache.valueMapping, err = queries.BindMapping(baseDocumentItemViewType, baseDocumentItemViewMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(baseDocumentItemViewType, baseDocumentItemViewMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
		if errors.Is(err, sql.ErrNoRows) {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "base: unable to upsert base_document_item_view")
	}

	if !cached {
		baseDocumentItemViewUpsertCacheMut.Lock()
		baseDocumentItemViewUpsertCache[key] = cache
		baseDocumentItemViewUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}
