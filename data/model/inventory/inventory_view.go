// Code generated by SQLBoiler 4.16.2 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package inventory

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/sqlboiler/v4/types"
	"github.com/volatiletech/strmangle"
)

// InventoryView is an object representing the database table.
type InventoryView struct {
	ID                  null.Int          `boil:"id" json:"id,omitempty" toml:"id" yaml:"id,omitempty"`
	InventoryNumber     null.String       `boil:"inventory_number" json:"inventory_number,omitempty" toml:"inventory_number" yaml:"inventory_number,omitempty"`
	ItemID              null.Int          `boil:"item_id" json:"item_id,omitempty" toml:"item_id" yaml:"item_id,omitempty"`
	QuantityReserved    types.NullDecimal `boil:"quantity_reserved" json:"quantity_reserved,omitempty" toml:"quantity_reserved" yaml:"quantity_reserved,omitempty"`
	QuantityAvailable   types.NullDecimal `boil:"quantity_available" json:"quantity_available,omitempty" toml:"quantity_available" yaml:"quantity_available,omitempty"`
	QuantityReturned    types.NullDecimal `boil:"quantity_returned" json:"quantity_returned,omitempty" toml:"quantity_returned" yaml:"quantity_returned,omitempty"`
	QuantityTotalGen    types.NullDecimal `boil:"quantity_total_gen" json:"quantity_total_gen,omitempty" toml:"quantity_total_gen" yaml:"quantity_total_gen,omitempty"`
	CostPerUnit         types.NullDecimal `boil:"cost_per_unit" json:"cost_per_unit,omitempty" toml:"cost_per_unit" yaml:"cost_per_unit,omitempty"`
	PricePerUnit        types.NullDecimal `boil:"price_per_unit" json:"price_per_unit,omitempty" toml:"price_per_unit" yaml:"price_per_unit,omitempty"`
	TotalValueOnHandGen types.NullDecimal `boil:"total_value_on_hand_gen" json:"total_value_on_hand_gen,omitempty" toml:"total_value_on_hand_gen" yaml:"total_value_on_hand_gen,omitempty"`
	ReorderLevel        types.NullDecimal `boil:"reorder_level" json:"reorder_level,omitempty" toml:"reorder_level" yaml:"reorder_level,omitempty"`
	ReorderQuantity     types.NullDecimal `boil:"reorder_quantity" json:"reorder_quantity,omitempty" toml:"reorder_quantity" yaml:"reorder_quantity,omitempty"`
	IsDiscontinued      null.Bool         `boil:"is_discontinued" json:"is_discontinued,omitempty" toml:"is_discontinued" yaml:"is_discontinued,omitempty"`
	Remarks             null.String       `boil:"remarks" json:"remarks,omitempty" toml:"remarks" yaml:"remarks,omitempty"`
	CreatedAt           null.Time         `boil:"created_at" json:"created_at,omitempty" toml:"created_at" yaml:"created_at,omitempty"`
	UpdatedAt           null.Time         `boil:"updated_at" json:"updated_at,omitempty" toml:"updated_at" yaml:"updated_at,omitempty"`
	DeletedAt           null.Time         `boil:"deleted_at" json:"deleted_at,omitempty" toml:"deleted_at" yaml:"deleted_at,omitempty"`
	Item                null.JSON         `boil:"item" json:"item,omitempty" toml:"item" yaml:"item,omitempty"`
	Transactions        null.JSON         `boil:"transactions" json:"transactions,omitempty" toml:"transactions" yaml:"transactions,omitempty"`
}

var InventoryViewColumns = struct {
	ID                  string
	InventoryNumber     string
	ItemID              string
	QuantityReserved    string
	QuantityAvailable   string
	QuantityReturned    string
	QuantityTotalGen    string
	CostPerUnit         string
	PricePerUnit        string
	TotalValueOnHandGen string
	ReorderLevel        string
	ReorderQuantity     string
	IsDiscontinued      string
	Remarks             string
	CreatedAt           string
	UpdatedAt           string
	DeletedAt           string
	Item                string
	Transactions        string
}{
	ID:                  "id",
	InventoryNumber:     "inventory_number",
	ItemID:              "item_id",
	QuantityReserved:    "quantity_reserved",
	QuantityAvailable:   "quantity_available",
	QuantityReturned:    "quantity_returned",
	QuantityTotalGen:    "quantity_total_gen",
	CostPerUnit:         "cost_per_unit",
	PricePerUnit:        "price_per_unit",
	TotalValueOnHandGen: "total_value_on_hand_gen",
	ReorderLevel:        "reorder_level",
	ReorderQuantity:     "reorder_quantity",
	IsDiscontinued:      "is_discontinued",
	Remarks:             "remarks",
	CreatedAt:           "created_at",
	UpdatedAt:           "updated_at",
	DeletedAt:           "deleted_at",
	Item:                "item",
	Transactions:        "transactions",
}

var InventoryViewTableColumns = struct {
	ID                  string
	InventoryNumber     string
	ItemID              string
	QuantityReserved    string
	QuantityAvailable   string
	QuantityReturned    string
	QuantityTotalGen    string
	CostPerUnit         string
	PricePerUnit        string
	TotalValueOnHandGen string
	ReorderLevel        string
	ReorderQuantity     string
	IsDiscontinued      string
	Remarks             string
	CreatedAt           string
	UpdatedAt           string
	DeletedAt           string
	Item                string
	Transactions        string
}{
	ID:                  "inventory_view.id",
	InventoryNumber:     "inventory_view.inventory_number",
	ItemID:              "inventory_view.item_id",
	QuantityReserved:    "inventory_view.quantity_reserved",
	QuantityAvailable:   "inventory_view.quantity_available",
	QuantityReturned:    "inventory_view.quantity_returned",
	QuantityTotalGen:    "inventory_view.quantity_total_gen",
	CostPerUnit:         "inventory_view.cost_per_unit",
	PricePerUnit:        "inventory_view.price_per_unit",
	TotalValueOnHandGen: "inventory_view.total_value_on_hand_gen",
	ReorderLevel:        "inventory_view.reorder_level",
	ReorderQuantity:     "inventory_view.reorder_quantity",
	IsDiscontinued:      "inventory_view.is_discontinued",
	Remarks:             "inventory_view.remarks",
	CreatedAt:           "inventory_view.created_at",
	UpdatedAt:           "inventory_view.updated_at",
	DeletedAt:           "inventory_view.deleted_at",
	Item:                "inventory_view.item",
	Transactions:        "inventory_view.transactions",
}

// Generated where

var InventoryViewWhere = struct {
	ID                  whereHelpernull_Int
	InventoryNumber     whereHelpernull_String
	ItemID              whereHelpernull_Int
	QuantityReserved    whereHelpertypes_NullDecimal
	QuantityAvailable   whereHelpertypes_NullDecimal
	QuantityReturned    whereHelpertypes_NullDecimal
	QuantityTotalGen    whereHelpertypes_NullDecimal
	CostPerUnit         whereHelpertypes_NullDecimal
	PricePerUnit        whereHelpertypes_NullDecimal
	TotalValueOnHandGen whereHelpertypes_NullDecimal
	ReorderLevel        whereHelpertypes_NullDecimal
	ReorderQuantity     whereHelpertypes_NullDecimal
	IsDiscontinued      whereHelpernull_Bool
	Remarks             whereHelpernull_String
	CreatedAt           whereHelpernull_Time
	UpdatedAt           whereHelpernull_Time
	DeletedAt           whereHelpernull_Time
	Item                whereHelpernull_JSON
	Transactions        whereHelpernull_JSON
}{
	ID:                  whereHelpernull_Int{field: "\"inventory\".\"inventory_view\".\"id\""},
	InventoryNumber:     whereHelpernull_String{field: "\"inventory\".\"inventory_view\".\"inventory_number\""},
	ItemID:              whereHelpernull_Int{field: "\"inventory\".\"inventory_view\".\"item_id\""},
	QuantityReserved:    whereHelpertypes_NullDecimal{field: "\"inventory\".\"inventory_view\".\"quantity_reserved\""},
	QuantityAvailable:   whereHelpertypes_NullDecimal{field: "\"inventory\".\"inventory_view\".\"quantity_available\""},
	QuantityReturned:    whereHelpertypes_NullDecimal{field: "\"inventory\".\"inventory_view\".\"quantity_returned\""},
	QuantityTotalGen:    whereHelpertypes_NullDecimal{field: "\"inventory\".\"inventory_view\".\"quantity_total_gen\""},
	CostPerUnit:         whereHelpertypes_NullDecimal{field: "\"inventory\".\"inventory_view\".\"cost_per_unit\""},
	PricePerUnit:        whereHelpertypes_NullDecimal{field: "\"inventory\".\"inventory_view\".\"price_per_unit\""},
	TotalValueOnHandGen: whereHelpertypes_NullDecimal{field: "\"inventory\".\"inventory_view\".\"total_value_on_hand_gen\""},
	ReorderLevel:        whereHelpertypes_NullDecimal{field: "\"inventory\".\"inventory_view\".\"reorder_level\""},
	ReorderQuantity:     whereHelpertypes_NullDecimal{field: "\"inventory\".\"inventory_view\".\"reorder_quantity\""},
	IsDiscontinued:      whereHelpernull_Bool{field: "\"inventory\".\"inventory_view\".\"is_discontinued\""},
	Remarks:             whereHelpernull_String{field: "\"inventory\".\"inventory_view\".\"remarks\""},
	CreatedAt:           whereHelpernull_Time{field: "\"inventory\".\"inventory_view\".\"created_at\""},
	UpdatedAt:           whereHelpernull_Time{field: "\"inventory\".\"inventory_view\".\"updated_at\""},
	DeletedAt:           whereHelpernull_Time{field: "\"inventory\".\"inventory_view\".\"deleted_at\""},
	Item:                whereHelpernull_JSON{field: "\"inventory\".\"inventory_view\".\"item\""},
	Transactions:        whereHelpernull_JSON{field: "\"inventory\".\"inventory_view\".\"transactions\""},
}

var (
	inventoryViewAllColumns            = []string{"id", "inventory_number", "item_id", "quantity_reserved", "quantity_available", "quantity_returned", "quantity_total_gen", "cost_per_unit", "price_per_unit", "total_value_on_hand_gen", "reorder_level", "reorder_quantity", "is_discontinued", "remarks", "created_at", "updated_at", "deleted_at", "item", "transactions"}
	inventoryViewColumnsWithoutDefault = []string{}
	inventoryViewColumnsWithDefault    = []string{"id", "inventory_number", "item_id", "quantity_reserved", "quantity_available", "quantity_returned", "quantity_total_gen", "cost_per_unit", "price_per_unit", "total_value_on_hand_gen", "reorder_level", "reorder_quantity", "is_discontinued", "remarks", "created_at", "updated_at", "deleted_at", "item", "transactions"}
	inventoryViewPrimaryKeyColumns     = []string{}
	inventoryViewGeneratedColumns      = []string{}
)

type (
	// InventoryViewSlice is an alias for a slice of pointers to InventoryView.
	// This should almost always be used instead of []InventoryView.
	InventoryViewSlice []*InventoryView
	// InventoryViewHook is the signature for custom InventoryView hook methods
	InventoryViewHook func(context.Context, boil.ContextExecutor, *InventoryView) error

	inventoryViewQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	inventoryViewType           = reflect.TypeOf(&InventoryView{})
	inventoryViewMapping        = queries.MakeStructMapping(inventoryViewType)
	inventoryViewInsertCacheMut sync.RWMutex
	inventoryViewInsertCache    = make(map[string]insertCache)
	inventoryViewUpdateCacheMut sync.RWMutex
	inventoryViewUpdateCache    = make(map[string]updateCache)
	inventoryViewUpsertCacheMut sync.RWMutex
	inventoryViewUpsertCache    = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
	// These are used in some views
	_ = fmt.Sprintln("")
	_ = reflect.Int
	_ = strings.Builder{}
	_ = sync.Mutex{}
	_ = strmangle.Plural("")
	_ = strconv.IntSize
)

var inventoryViewAfterSelectMu sync.Mutex
var inventoryViewAfterSelectHooks []InventoryViewHook

var inventoryViewBeforeInsertMu sync.Mutex
var inventoryViewBeforeInsertHooks []InventoryViewHook
var inventoryViewAfterInsertMu sync.Mutex
var inventoryViewAfterInsertHooks []InventoryViewHook

var inventoryViewBeforeUpsertMu sync.Mutex
var inventoryViewBeforeUpsertHooks []InventoryViewHook
var inventoryViewAfterUpsertMu sync.Mutex
var inventoryViewAfterUpsertHooks []InventoryViewHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *InventoryView) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range inventoryViewAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *InventoryView) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range inventoryViewBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *InventoryView) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range inventoryViewAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *InventoryView) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range inventoryViewBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *InventoryView) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range inventoryViewAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddInventoryViewHook registers your hook function for all future operations.
func AddInventoryViewHook(hookPoint boil.HookPoint, inventoryViewHook InventoryViewHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		inventoryViewAfterSelectMu.Lock()
		inventoryViewAfterSelectHooks = append(inventoryViewAfterSelectHooks, inventoryViewHook)
		inventoryViewAfterSelectMu.Unlock()
	case boil.BeforeInsertHook:
		inventoryViewBeforeInsertMu.Lock()
		inventoryViewBeforeInsertHooks = append(inventoryViewBeforeInsertHooks, inventoryViewHook)
		inventoryViewBeforeInsertMu.Unlock()
	case boil.AfterInsertHook:
		inventoryViewAfterInsertMu.Lock()
		inventoryViewAfterInsertHooks = append(inventoryViewAfterInsertHooks, inventoryViewHook)
		inventoryViewAfterInsertMu.Unlock()
	case boil.BeforeUpsertHook:
		inventoryViewBeforeUpsertMu.Lock()
		inventoryViewBeforeUpsertHooks = append(inventoryViewBeforeUpsertHooks, inventoryViewHook)
		inventoryViewBeforeUpsertMu.Unlock()
	case boil.AfterUpsertHook:
		inventoryViewAfterUpsertMu.Lock()
		inventoryViewAfterUpsertHooks = append(inventoryViewAfterUpsertHooks, inventoryViewHook)
		inventoryViewAfterUpsertMu.Unlock()
	}
}

// One returns a single inventoryView record from the query.
func (q inventoryViewQuery) One(ctx context.Context, exec boil.ContextExecutor) (*InventoryView, error) {
	o := &InventoryView{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "inventory: failed to execute a one query for inventory_view")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all InventoryView records from the query.
func (q inventoryViewQuery) All(ctx context.Context, exec boil.ContextExecutor) (InventoryViewSlice, error) {
	var o []*InventoryView

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "inventory: failed to assign all query results to InventoryView slice")
	}

	if len(inventoryViewAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all InventoryView records in the query.
func (q inventoryViewQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "inventory: failed to count inventory_view rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q inventoryViewQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "inventory: failed to check if inventory_view exists")
	}

	return count > 0, nil
}

// InventoryViews retrieves all the records using an executor.
func InventoryViews(mods ...qm.QueryMod) inventoryViewQuery {
	mods = append(mods, qm.From("\"inventory\".\"inventory_view\""))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"\"inventory\".\"inventory_view\".*"})
	}

	return inventoryViewQuery{q}
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *InventoryView) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("inventory: no inventory_view provided for insertion")
	}

	var err error
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if queries.MustTime(o.CreatedAt).IsZero() {
			queries.SetScanner(&o.CreatedAt, currTime)
		}
		if queries.MustTime(o.UpdatedAt).IsZero() {
			queries.SetScanner(&o.UpdatedAt, currTime)
		}
	}

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(inventoryViewColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	inventoryViewInsertCacheMut.RLock()
	cache, cached := inventoryViewInsertCache[key]
	inventoryViewInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			inventoryViewAllColumns,
			inventoryViewColumnsWithDefault,
			inventoryViewColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(inventoryViewType, inventoryViewMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(inventoryViewType, inventoryViewMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"inventory\".\"inventory_view\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"inventory\".\"inventory_view\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "inventory: unable to insert into inventory_view")
	}

	if !cached {
		inventoryViewInsertCacheMut.Lock()
		inventoryViewInsertCache[key] = cache
		inventoryViewInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *InventoryView) Upsert(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns, opts ...UpsertOptionFunc) error {
	if o == nil {
		return errors.New("inventory: no inventory_view provided for upsert")
	}
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if queries.MustTime(o.CreatedAt).IsZero() {
			queries.SetScanner(&o.CreatedAt, currTime)
		}
		queries.SetScanner(&o.UpdatedAt, currTime)
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(inventoryViewColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	inventoryViewUpsertCacheMut.RLock()
	cache, cached := inventoryViewUpsertCache[key]
	inventoryViewUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, _ := insertColumns.InsertColumnSet(
			inventoryViewAllColumns,
			inventoryViewColumnsWithDefault,
			inventoryViewColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			inventoryViewAllColumns,
			inventoryViewPrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("inventory: unable to upsert inventory_view, could not build update column list")
		}

		ret := strmangle.SetComplement(inventoryViewAllColumns, strmangle.SetIntersect(insert, update))

		conflict := conflictColumns
		if len(conflict) == 0 && updateOnConflict && len(update) != 0 {
			if len(inventoryViewPrimaryKeyColumns) == 0 {
				return errors.New("inventory: unable to upsert inventory_view, could not build conflict column list")
			}

			conflict = make([]string, len(inventoryViewPrimaryKeyColumns))
			copy(conflict, inventoryViewPrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"inventory\".\"inventory_view\"", updateOnConflict, ret, update, conflict, insert, opts...)

		cache.valueMapping, err = queries.BindMapping(inventoryViewType, inventoryViewMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(inventoryViewType, inventoryViewMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
		if errors.Is(err, sql.ErrNoRows) {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "inventory: unable to upsert inventory_view")
	}

	if !cached {
		inventoryViewUpsertCacheMut.Lock()
		inventoryViewUpsertCache[key] = cache
		inventoryViewUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}
