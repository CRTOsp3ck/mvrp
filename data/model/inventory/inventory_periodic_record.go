// Code generated by SQLBoiler 4.16.2 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package inventory

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/sqlboiler/v4/types"
	"github.com/volatiletech/strmangle"
)

// InventoryPeriodicRecord is an object representing the database table.
type InventoryPeriodicRecord struct {
	ID                           int               `boil:"id" json:"id" toml:"id" yaml:"id"`
	InventoryID                  int               `boil:"inventory_id" json:"inventory_id" toml:"inventory_id" yaml:"inventory_id"`
	RecordStartDate              null.Time         `boil:"record_start_date" json:"record_start_date,omitempty" toml:"record_start_date" yaml:"record_start_date,omitempty"`
	RecordStartQuantityReserved  types.NullDecimal `boil:"record_start_quantity_reserved" json:"record_start_quantity_reserved,omitempty" toml:"record_start_quantity_reserved" yaml:"record_start_quantity_reserved,omitempty"`
	RecordStartQuantityAvailable types.NullDecimal `boil:"record_start_quantity_available" json:"record_start_quantity_available,omitempty" toml:"record_start_quantity_available" yaml:"record_start_quantity_available,omitempty"`
	RecordStartQuantityReturned  types.NullDecimal `boil:"record_start_quantity_returned" json:"record_start_quantity_returned,omitempty" toml:"record_start_quantity_returned" yaml:"record_start_quantity_returned,omitempty"`
	RecordStartQuantityTotal     types.NullDecimal `boil:"record_start_quantity_total" json:"record_start_quantity_total,omitempty" toml:"record_start_quantity_total" yaml:"record_start_quantity_total,omitempty"`
	RecordEndDate                null.Time         `boil:"record_end_date" json:"record_end_date,omitempty" toml:"record_end_date" yaml:"record_end_date,omitempty"`
	RecordEndQuantityReserved    types.NullDecimal `boil:"record_end_quantity_reserved" json:"record_end_quantity_reserved,omitempty" toml:"record_end_quantity_reserved" yaml:"record_end_quantity_reserved,omitempty"`
	RecordEndQuantityAvailable   types.NullDecimal `boil:"record_end_quantity_available" json:"record_end_quantity_available,omitempty" toml:"record_end_quantity_available" yaml:"record_end_quantity_available,omitempty"`
	RecordEndQuantityReturned    types.NullDecimal `boil:"record_end_quantity_returned" json:"record_end_quantity_returned,omitempty" toml:"record_end_quantity_returned" yaml:"record_end_quantity_returned,omitempty"`
	RecordEndQuantityTotal       types.NullDecimal `boil:"record_end_quantity_total" json:"record_end_quantity_total,omitempty" toml:"record_end_quantity_total" yaml:"record_end_quantity_total,omitempty"`
	Remarks                      null.String       `boil:"remarks" json:"remarks,omitempty" toml:"remarks" yaml:"remarks,omitempty"`
	CreatedAt                    time.Time         `boil:"created_at" json:"created_at" toml:"created_at" yaml:"created_at"`
	UpdatedAt                    time.Time         `boil:"updated_at" json:"updated_at" toml:"updated_at" yaml:"updated_at"`
	DeletedAt                    null.Time         `boil:"deleted_at" json:"deleted_at,omitempty" toml:"deleted_at" yaml:"deleted_at,omitempty"`

	R *inventoryPeriodicRecordR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L inventoryPeriodicRecordL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var InventoryPeriodicRecordColumns = struct {
	ID                           string
	InventoryID                  string
	RecordStartDate              string
	RecordStartQuantityReserved  string
	RecordStartQuantityAvailable string
	RecordStartQuantityReturned  string
	RecordStartQuantityTotal     string
	RecordEndDate                string
	RecordEndQuantityReserved    string
	RecordEndQuantityAvailable   string
	RecordEndQuantityReturned    string
	RecordEndQuantityTotal       string
	Remarks                      string
	CreatedAt                    string
	UpdatedAt                    string
	DeletedAt                    string
}{
	ID:                           "id",
	InventoryID:                  "inventory_id",
	RecordStartDate:              "record_start_date",
	RecordStartQuantityReserved:  "record_start_quantity_reserved",
	RecordStartQuantityAvailable: "record_start_quantity_available",
	RecordStartQuantityReturned:  "record_start_quantity_returned",
	RecordStartQuantityTotal:     "record_start_quantity_total",
	RecordEndDate:                "record_end_date",
	RecordEndQuantityReserved:    "record_end_quantity_reserved",
	RecordEndQuantityAvailable:   "record_end_quantity_available",
	RecordEndQuantityReturned:    "record_end_quantity_returned",
	RecordEndQuantityTotal:       "record_end_quantity_total",
	Remarks:                      "remarks",
	CreatedAt:                    "created_at",
	UpdatedAt:                    "updated_at",
	DeletedAt:                    "deleted_at",
}

var InventoryPeriodicRecordTableColumns = struct {
	ID                           string
	InventoryID                  string
	RecordStartDate              string
	RecordStartQuantityReserved  string
	RecordStartQuantityAvailable string
	RecordStartQuantityReturned  string
	RecordStartQuantityTotal     string
	RecordEndDate                string
	RecordEndQuantityReserved    string
	RecordEndQuantityAvailable   string
	RecordEndQuantityReturned    string
	RecordEndQuantityTotal       string
	Remarks                      string
	CreatedAt                    string
	UpdatedAt                    string
	DeletedAt                    string
}{
	ID:                           "inventory_periodic_record.id",
	InventoryID:                  "inventory_periodic_record.inventory_id",
	RecordStartDate:              "inventory_periodic_record.record_start_date",
	RecordStartQuantityReserved:  "inventory_periodic_record.record_start_quantity_reserved",
	RecordStartQuantityAvailable: "inventory_periodic_record.record_start_quantity_available",
	RecordStartQuantityReturned:  "inventory_periodic_record.record_start_quantity_returned",
	RecordStartQuantityTotal:     "inventory_periodic_record.record_start_quantity_total",
	RecordEndDate:                "inventory_periodic_record.record_end_date",
	RecordEndQuantityReserved:    "inventory_periodic_record.record_end_quantity_reserved",
	RecordEndQuantityAvailable:   "inventory_periodic_record.record_end_quantity_available",
	RecordEndQuantityReturned:    "inventory_periodic_record.record_end_quantity_returned",
	RecordEndQuantityTotal:       "inventory_periodic_record.record_end_quantity_total",
	Remarks:                      "inventory_periodic_record.remarks",
	CreatedAt:                    "inventory_periodic_record.created_at",
	UpdatedAt:                    "inventory_periodic_record.updated_at",
	DeletedAt:                    "inventory_periodic_record.deleted_at",
}

// Generated where

var InventoryPeriodicRecordWhere = struct {
	ID                           whereHelperint
	InventoryID                  whereHelperint
	RecordStartDate              whereHelpernull_Time
	RecordStartQuantityReserved  whereHelpertypes_NullDecimal
	RecordStartQuantityAvailable whereHelpertypes_NullDecimal
	RecordStartQuantityReturned  whereHelpertypes_NullDecimal
	RecordStartQuantityTotal     whereHelpertypes_NullDecimal
	RecordEndDate                whereHelpernull_Time
	RecordEndQuantityReserved    whereHelpertypes_NullDecimal
	RecordEndQuantityAvailable   whereHelpertypes_NullDecimal
	RecordEndQuantityReturned    whereHelpertypes_NullDecimal
	RecordEndQuantityTotal       whereHelpertypes_NullDecimal
	Remarks                      whereHelpernull_String
	CreatedAt                    whereHelpertime_Time
	UpdatedAt                    whereHelpertime_Time
	DeletedAt                    whereHelpernull_Time
}{
	ID:                           whereHelperint{field: "\"inventory\".\"inventory_periodic_record\".\"id\""},
	InventoryID:                  whereHelperint{field: "\"inventory\".\"inventory_periodic_record\".\"inventory_id\""},
	RecordStartDate:              whereHelpernull_Time{field: "\"inventory\".\"inventory_periodic_record\".\"record_start_date\""},
	RecordStartQuantityReserved:  whereHelpertypes_NullDecimal{field: "\"inventory\".\"inventory_periodic_record\".\"record_start_quantity_reserved\""},
	RecordStartQuantityAvailable: whereHelpertypes_NullDecimal{field: "\"inventory\".\"inventory_periodic_record\".\"record_start_quantity_available\""},
	RecordStartQuantityReturned:  whereHelpertypes_NullDecimal{field: "\"inventory\".\"inventory_periodic_record\".\"record_start_quantity_returned\""},
	RecordStartQuantityTotal:     whereHelpertypes_NullDecimal{field: "\"inventory\".\"inventory_periodic_record\".\"record_start_quantity_total\""},
	RecordEndDate:                whereHelpernull_Time{field: "\"inventory\".\"inventory_periodic_record\".\"record_end_date\""},
	RecordEndQuantityReserved:    whereHelpertypes_NullDecimal{field: "\"inventory\".\"inventory_periodic_record\".\"record_end_quantity_reserved\""},
	RecordEndQuantityAvailable:   whereHelpertypes_NullDecimal{field: "\"inventory\".\"inventory_periodic_record\".\"record_end_quantity_available\""},
	RecordEndQuantityReturned:    whereHelpertypes_NullDecimal{field: "\"inventory\".\"inventory_periodic_record\".\"record_end_quantity_returned\""},
	RecordEndQuantityTotal:       whereHelpertypes_NullDecimal{field: "\"inventory\".\"inventory_periodic_record\".\"record_end_quantity_total\""},
	Remarks:                      whereHelpernull_String{field: "\"inventory\".\"inventory_periodic_record\".\"remarks\""},
	CreatedAt:                    whereHelpertime_Time{field: "\"inventory\".\"inventory_periodic_record\".\"created_at\""},
	UpdatedAt:                    whereHelpertime_Time{field: "\"inventory\".\"inventory_periodic_record\".\"updated_at\""},
	DeletedAt:                    whereHelpernull_Time{field: "\"inventory\".\"inventory_periodic_record\".\"deleted_at\""},
}

// InventoryPeriodicRecordRels is where relationship names are stored.
var InventoryPeriodicRecordRels = struct {
	Inventory string
}{
	Inventory: "Inventory",
}

// inventoryPeriodicRecordR is where relationships are stored.
type inventoryPeriodicRecordR struct {
	Inventory *Inventory `boil:"Inventory" json:"Inventory" toml:"Inventory" yaml:"Inventory"`
}

// NewStruct creates a new relationship struct
func (*inventoryPeriodicRecordR) NewStruct() *inventoryPeriodicRecordR {
	return &inventoryPeriodicRecordR{}
}

func (r *inventoryPeriodicRecordR) GetInventory() *Inventory {
	if r == nil {
		return nil
	}
	return r.Inventory
}

// inventoryPeriodicRecordL is where Load methods for each relationship are stored.
type inventoryPeriodicRecordL struct{}

var (
	inventoryPeriodicRecordAllColumns            = []string{"id", "inventory_id", "record_start_date", "record_start_quantity_reserved", "record_start_quantity_available", "record_start_quantity_returned", "record_start_quantity_total", "record_end_date", "record_end_quantity_reserved", "record_end_quantity_available", "record_end_quantity_returned", "record_end_quantity_total", "remarks", "created_at", "updated_at", "deleted_at"}
	inventoryPeriodicRecordColumnsWithoutDefault = []string{"id", "inventory_id", "created_at", "updated_at"}
	inventoryPeriodicRecordColumnsWithDefault    = []string{"record_start_date", "record_start_quantity_reserved", "record_start_quantity_available", "record_start_quantity_returned", "record_start_quantity_total", "record_end_date", "record_end_quantity_reserved", "record_end_quantity_available", "record_end_quantity_returned", "record_end_quantity_total", "remarks", "deleted_at"}
	inventoryPeriodicRecordPrimaryKeyColumns     = []string{"id"}
	inventoryPeriodicRecordGeneratedColumns      = []string{}
)

type (
	// InventoryPeriodicRecordSlice is an alias for a slice of pointers to InventoryPeriodicRecord.
	// This should almost always be used instead of []InventoryPeriodicRecord.
	InventoryPeriodicRecordSlice []*InventoryPeriodicRecord
	// InventoryPeriodicRecordHook is the signature for custom InventoryPeriodicRecord hook methods
	InventoryPeriodicRecordHook func(context.Context, boil.ContextExecutor, *InventoryPeriodicRecord) error

	inventoryPeriodicRecordQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	inventoryPeriodicRecordType                 = reflect.TypeOf(&InventoryPeriodicRecord{})
	inventoryPeriodicRecordMapping              = queries.MakeStructMapping(inventoryPeriodicRecordType)
	inventoryPeriodicRecordPrimaryKeyMapping, _ = queries.BindMapping(inventoryPeriodicRecordType, inventoryPeriodicRecordMapping, inventoryPeriodicRecordPrimaryKeyColumns)
	inventoryPeriodicRecordInsertCacheMut       sync.RWMutex
	inventoryPeriodicRecordInsertCache          = make(map[string]insertCache)
	inventoryPeriodicRecordUpdateCacheMut       sync.RWMutex
	inventoryPeriodicRecordUpdateCache          = make(map[string]updateCache)
	inventoryPeriodicRecordUpsertCacheMut       sync.RWMutex
	inventoryPeriodicRecordUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var inventoryPeriodicRecordAfterSelectMu sync.Mutex
var inventoryPeriodicRecordAfterSelectHooks []InventoryPeriodicRecordHook

var inventoryPeriodicRecordBeforeInsertMu sync.Mutex
var inventoryPeriodicRecordBeforeInsertHooks []InventoryPeriodicRecordHook
var inventoryPeriodicRecordAfterInsertMu sync.Mutex
var inventoryPeriodicRecordAfterInsertHooks []InventoryPeriodicRecordHook

var inventoryPeriodicRecordBeforeUpdateMu sync.Mutex
var inventoryPeriodicRecordBeforeUpdateHooks []InventoryPeriodicRecordHook
var inventoryPeriodicRecordAfterUpdateMu sync.Mutex
var inventoryPeriodicRecordAfterUpdateHooks []InventoryPeriodicRecordHook

var inventoryPeriodicRecordBeforeDeleteMu sync.Mutex
var inventoryPeriodicRecordBeforeDeleteHooks []InventoryPeriodicRecordHook
var inventoryPeriodicRecordAfterDeleteMu sync.Mutex
var inventoryPeriodicRecordAfterDeleteHooks []InventoryPeriodicRecordHook

var inventoryPeriodicRecordBeforeUpsertMu sync.Mutex
var inventoryPeriodicRecordBeforeUpsertHooks []InventoryPeriodicRecordHook
var inventoryPeriodicRecordAfterUpsertMu sync.Mutex
var inventoryPeriodicRecordAfterUpsertHooks []InventoryPeriodicRecordHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *InventoryPeriodicRecord) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range inventoryPeriodicRecordAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *InventoryPeriodicRecord) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range inventoryPeriodicRecordBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *InventoryPeriodicRecord) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range inventoryPeriodicRecordAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *InventoryPeriodicRecord) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range inventoryPeriodicRecordBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *InventoryPeriodicRecord) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range inventoryPeriodicRecordAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *InventoryPeriodicRecord) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range inventoryPeriodicRecordBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *InventoryPeriodicRecord) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range inventoryPeriodicRecordAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *InventoryPeriodicRecord) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range inventoryPeriodicRecordBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *InventoryPeriodicRecord) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range inventoryPeriodicRecordAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddInventoryPeriodicRecordHook registers your hook function for all future operations.
func AddInventoryPeriodicRecordHook(hookPoint boil.HookPoint, inventoryPeriodicRecordHook InventoryPeriodicRecordHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		inventoryPeriodicRecordAfterSelectMu.Lock()
		inventoryPeriodicRecordAfterSelectHooks = append(inventoryPeriodicRecordAfterSelectHooks, inventoryPeriodicRecordHook)
		inventoryPeriodicRecordAfterSelectMu.Unlock()
	case boil.BeforeInsertHook:
		inventoryPeriodicRecordBeforeInsertMu.Lock()
		inventoryPeriodicRecordBeforeInsertHooks = append(inventoryPeriodicRecordBeforeInsertHooks, inventoryPeriodicRecordHook)
		inventoryPeriodicRecordBeforeInsertMu.Unlock()
	case boil.AfterInsertHook:
		inventoryPeriodicRecordAfterInsertMu.Lock()
		inventoryPeriodicRecordAfterInsertHooks = append(inventoryPeriodicRecordAfterInsertHooks, inventoryPeriodicRecordHook)
		inventoryPeriodicRecordAfterInsertMu.Unlock()
	case boil.BeforeUpdateHook:
		inventoryPeriodicRecordBeforeUpdateMu.Lock()
		inventoryPeriodicRecordBeforeUpdateHooks = append(inventoryPeriodicRecordBeforeUpdateHooks, inventoryPeriodicRecordHook)
		inventoryPeriodicRecordBeforeUpdateMu.Unlock()
	case boil.AfterUpdateHook:
		inventoryPeriodicRecordAfterUpdateMu.Lock()
		inventoryPeriodicRecordAfterUpdateHooks = append(inventoryPeriodicRecordAfterUpdateHooks, inventoryPeriodicRecordHook)
		inventoryPeriodicRecordAfterUpdateMu.Unlock()
	case boil.BeforeDeleteHook:
		inventoryPeriodicRecordBeforeDeleteMu.Lock()
		inventoryPeriodicRecordBeforeDeleteHooks = append(inventoryPeriodicRecordBeforeDeleteHooks, inventoryPeriodicRecordHook)
		inventoryPeriodicRecordBeforeDeleteMu.Unlock()
	case boil.AfterDeleteHook:
		inventoryPeriodicRecordAfterDeleteMu.Lock()
		inventoryPeriodicRecordAfterDeleteHooks = append(inventoryPeriodicRecordAfterDeleteHooks, inventoryPeriodicRecordHook)
		inventoryPeriodicRecordAfterDeleteMu.Unlock()
	case boil.BeforeUpsertHook:
		inventoryPeriodicRecordBeforeUpsertMu.Lock()
		inventoryPeriodicRecordBeforeUpsertHooks = append(inventoryPeriodicRecordBeforeUpsertHooks, inventoryPeriodicRecordHook)
		inventoryPeriodicRecordBeforeUpsertMu.Unlock()
	case boil.AfterUpsertHook:
		inventoryPeriodicRecordAfterUpsertMu.Lock()
		inventoryPeriodicRecordAfterUpsertHooks = append(inventoryPeriodicRecordAfterUpsertHooks, inventoryPeriodicRecordHook)
		inventoryPeriodicRecordAfterUpsertMu.Unlock()
	}
}

// One returns a single inventoryPeriodicRecord record from the query.
func (q inventoryPeriodicRecordQuery) One(ctx context.Context, exec boil.ContextExecutor) (*InventoryPeriodicRecord, error) {
	o := &InventoryPeriodicRecord{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "inventory: failed to execute a one query for inventory_periodic_record")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all InventoryPeriodicRecord records from the query.
func (q inventoryPeriodicRecordQuery) All(ctx context.Context, exec boil.ContextExecutor) (InventoryPeriodicRecordSlice, error) {
	var o []*InventoryPeriodicRecord

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "inventory: failed to assign all query results to InventoryPeriodicRecord slice")
	}

	if len(inventoryPeriodicRecordAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all InventoryPeriodicRecord records in the query.
func (q inventoryPeriodicRecordQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "inventory: failed to count inventory_periodic_record rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q inventoryPeriodicRecordQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "inventory: failed to check if inventory_periodic_record exists")
	}

	return count > 0, nil
}

// Inventory pointed to by the foreign key.
func (o *InventoryPeriodicRecord) Inventory(mods ...qm.QueryMod) inventoryQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.InventoryID),
	}

	queryMods = append(queryMods, mods...)

	return Inventories(queryMods...)
}

// LoadInventory allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (inventoryPeriodicRecordL) LoadInventory(ctx context.Context, e boil.ContextExecutor, singular bool, maybeInventoryPeriodicRecord interface{}, mods queries.Applicator) error {
	var slice []*InventoryPeriodicRecord
	var object *InventoryPeriodicRecord

	if singular {
		var ok bool
		object, ok = maybeInventoryPeriodicRecord.(*InventoryPeriodicRecord)
		if !ok {
			object = new(InventoryPeriodicRecord)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeInventoryPeriodicRecord)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeInventoryPeriodicRecord))
			}
		}
	} else {
		s, ok := maybeInventoryPeriodicRecord.(*[]*InventoryPeriodicRecord)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeInventoryPeriodicRecord)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeInventoryPeriodicRecord))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &inventoryPeriodicRecordR{}
		}
		args[object.InventoryID] = struct{}{}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &inventoryPeriodicRecordR{}
			}

			args[obj.InventoryID] = struct{}{}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`inventory.inventory`),
		qm.WhereIn(`inventory.inventory.id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Inventory")
	}

	var resultSlice []*Inventory
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Inventory")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for inventory")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for inventory")
	}

	if len(inventoryAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Inventory = foreign
		if foreign.R == nil {
			foreign.R = &inventoryR{}
		}
		foreign.R.InventoryPeriodicRecords = append(foreign.R.InventoryPeriodicRecords, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.InventoryID == foreign.ID {
				local.R.Inventory = foreign
				if foreign.R == nil {
					foreign.R = &inventoryR{}
				}
				foreign.R.InventoryPeriodicRecords = append(foreign.R.InventoryPeriodicRecords, local)
				break
			}
		}
	}

	return nil
}

// SetInventory of the inventoryPeriodicRecord to the related item.
// Sets o.R.Inventory to related.
// Adds o to related.R.InventoryPeriodicRecords.
func (o *InventoryPeriodicRecord) SetInventory(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Inventory) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"inventory\".\"inventory_periodic_record\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"inventory_id"}),
		strmangle.WhereClause("\"", "\"", 2, inventoryPeriodicRecordPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.InventoryID = related.ID
	if o.R == nil {
		o.R = &inventoryPeriodicRecordR{
			Inventory: related,
		}
	} else {
		o.R.Inventory = related
	}

	if related.R == nil {
		related.R = &inventoryR{
			InventoryPeriodicRecords: InventoryPeriodicRecordSlice{o},
		}
	} else {
		related.R.InventoryPeriodicRecords = append(related.R.InventoryPeriodicRecords, o)
	}

	return nil
}

// InventoryPeriodicRecords retrieves all the records using an executor.
func InventoryPeriodicRecords(mods ...qm.QueryMod) inventoryPeriodicRecordQuery {
	mods = append(mods, qm.From("\"inventory\".\"inventory_periodic_record\""))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"\"inventory\".\"inventory_periodic_record\".*"})
	}

	return inventoryPeriodicRecordQuery{q}
}

// FindInventoryPeriodicRecord retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindInventoryPeriodicRecord(ctx context.Context, exec boil.ContextExecutor, iD int, selectCols ...string) (*InventoryPeriodicRecord, error) {
	inventoryPeriodicRecordObj := &InventoryPeriodicRecord{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"inventory\".\"inventory_periodic_record\" where \"id\"=$1", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, inventoryPeriodicRecordObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "inventory: unable to select from inventory_periodic_record")
	}

	if err = inventoryPeriodicRecordObj.doAfterSelectHooks(ctx, exec); err != nil {
		return inventoryPeriodicRecordObj, err
	}

	return inventoryPeriodicRecordObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *InventoryPeriodicRecord) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("inventory: no inventory_periodic_record provided for insertion")
	}

	var err error
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
		if o.UpdatedAt.IsZero() {
			o.UpdatedAt = currTime
		}
	}

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(inventoryPeriodicRecordColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	inventoryPeriodicRecordInsertCacheMut.RLock()
	cache, cached := inventoryPeriodicRecordInsertCache[key]
	inventoryPeriodicRecordInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			inventoryPeriodicRecordAllColumns,
			inventoryPeriodicRecordColumnsWithDefault,
			inventoryPeriodicRecordColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(inventoryPeriodicRecordType, inventoryPeriodicRecordMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(inventoryPeriodicRecordType, inventoryPeriodicRecordMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"inventory\".\"inventory_periodic_record\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"inventory\".\"inventory_periodic_record\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "inventory: unable to insert into inventory_periodic_record")
	}

	if !cached {
		inventoryPeriodicRecordInsertCacheMut.Lock()
		inventoryPeriodicRecordInsertCache[key] = cache
		inventoryPeriodicRecordInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the InventoryPeriodicRecord.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *InventoryPeriodicRecord) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		o.UpdatedAt = currTime
	}

	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	inventoryPeriodicRecordUpdateCacheMut.RLock()
	cache, cached := inventoryPeriodicRecordUpdateCache[key]
	inventoryPeriodicRecordUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			inventoryPeriodicRecordAllColumns,
			inventoryPeriodicRecordPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("inventory: unable to update inventory_periodic_record, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"inventory\".\"inventory_periodic_record\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, inventoryPeriodicRecordPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(inventoryPeriodicRecordType, inventoryPeriodicRecordMapping, append(wl, inventoryPeriodicRecordPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "inventory: unable to update inventory_periodic_record row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "inventory: failed to get rows affected by update for inventory_periodic_record")
	}

	if !cached {
		inventoryPeriodicRecordUpdateCacheMut.Lock()
		inventoryPeriodicRecordUpdateCache[key] = cache
		inventoryPeriodicRecordUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q inventoryPeriodicRecordQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "inventory: unable to update all for inventory_periodic_record")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "inventory: unable to retrieve rows affected for inventory_periodic_record")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o InventoryPeriodicRecordSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("inventory: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), inventoryPeriodicRecordPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"inventory\".\"inventory_periodic_record\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, inventoryPeriodicRecordPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "inventory: unable to update all in inventoryPeriodicRecord slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "inventory: unable to retrieve rows affected all in update all inventoryPeriodicRecord")
	}
	return rowsAff, nil
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *InventoryPeriodicRecord) Upsert(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns, opts ...UpsertOptionFunc) error {
	if o == nil {
		return errors.New("inventory: no inventory_periodic_record provided for upsert")
	}
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
		o.UpdatedAt = currTime
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(inventoryPeriodicRecordColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	inventoryPeriodicRecordUpsertCacheMut.RLock()
	cache, cached := inventoryPeriodicRecordUpsertCache[key]
	inventoryPeriodicRecordUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, _ := insertColumns.InsertColumnSet(
			inventoryPeriodicRecordAllColumns,
			inventoryPeriodicRecordColumnsWithDefault,
			inventoryPeriodicRecordColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			inventoryPeriodicRecordAllColumns,
			inventoryPeriodicRecordPrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("inventory: unable to upsert inventory_periodic_record, could not build update column list")
		}

		ret := strmangle.SetComplement(inventoryPeriodicRecordAllColumns, strmangle.SetIntersect(insert, update))

		conflict := conflictColumns
		if len(conflict) == 0 && updateOnConflict && len(update) != 0 {
			if len(inventoryPeriodicRecordPrimaryKeyColumns) == 0 {
				return errors.New("inventory: unable to upsert inventory_periodic_record, could not build conflict column list")
			}

			conflict = make([]string, len(inventoryPeriodicRecordPrimaryKeyColumns))
			copy(conflict, inventoryPeriodicRecordPrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"inventory\".\"inventory_periodic_record\"", updateOnConflict, ret, update, conflict, insert, opts...)

		cache.valueMapping, err = queries.BindMapping(inventoryPeriodicRecordType, inventoryPeriodicRecordMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(inventoryPeriodicRecordType, inventoryPeriodicRecordMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
		if errors.Is(err, sql.ErrNoRows) {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "inventory: unable to upsert inventory_periodic_record")
	}

	if !cached {
		inventoryPeriodicRecordUpsertCacheMut.Lock()
		inventoryPeriodicRecordUpsertCache[key] = cache
		inventoryPeriodicRecordUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single InventoryPeriodicRecord record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *InventoryPeriodicRecord) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("inventory: no InventoryPeriodicRecord provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), inventoryPeriodicRecordPrimaryKeyMapping)
	sql := "DELETE FROM \"inventory\".\"inventory_periodic_record\" WHERE \"id\"=$1"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "inventory: unable to delete from inventory_periodic_record")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "inventory: failed to get rows affected by delete for inventory_periodic_record")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q inventoryPeriodicRecordQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("inventory: no inventoryPeriodicRecordQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "inventory: unable to delete all from inventory_periodic_record")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "inventory: failed to get rows affected by deleteall for inventory_periodic_record")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o InventoryPeriodicRecordSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(inventoryPeriodicRecordBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), inventoryPeriodicRecordPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"inventory\".\"inventory_periodic_record\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, inventoryPeriodicRecordPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "inventory: unable to delete all from inventoryPeriodicRecord slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "inventory: failed to get rows affected by deleteall for inventory_periodic_record")
	}

	if len(inventoryPeriodicRecordAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *InventoryPeriodicRecord) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindInventoryPeriodicRecord(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *InventoryPeriodicRecordSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := InventoryPeriodicRecordSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), inventoryPeriodicRecordPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"inventory\".\"inventory_periodic_record\".* FROM \"inventory\".\"inventory_periodic_record\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, inventoryPeriodicRecordPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "inventory: unable to reload all in InventoryPeriodicRecordSlice")
	}

	*o = slice

	return nil
}

// InventoryPeriodicRecordExists checks if the InventoryPeriodicRecord row exists.
func InventoryPeriodicRecordExists(ctx context.Context, exec boil.ContextExecutor, iD int) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"inventory\".\"inventory_periodic_record\" where \"id\"=$1 limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, iD)
	}
	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "inventory: unable to check if inventory_periodic_record exists")
	}

	return exists, nil
}

// Exists checks if the InventoryPeriodicRecord row exists.
func (o *InventoryPeriodicRecord) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	return InventoryPeriodicRecordExists(ctx, exec, o.ID)
}
