// Code generated by SQLBoiler 4.16.2 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package inventory

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/sqlboiler/v4/types"
	"github.com/volatiletech/strmangle"
)

// Inventory is an object representing the database table.
type Inventory struct {
	ID                  int               `boil:"id" json:"id" toml:"id" yaml:"id"`
	InventoryNumber     string            `boil:"inventory_number" json:"inventory_number" toml:"inventory_number" yaml:"inventory_number"`
	ItemID              null.Int          `boil:"item_id" json:"item_id,omitempty" toml:"item_id" yaml:"item_id,omitempty"`
	RecordStartDate     null.Time         `boil:"record_start_date" json:"record_start_date,omitempty" toml:"record_start_date" yaml:"record_start_date,omitempty"`
	RecordStartQuantity types.NullDecimal `boil:"record_start_quantity" json:"record_start_quantity,omitempty" toml:"record_start_quantity" yaml:"record_start_quantity,omitempty"`
	RecordEndDate       null.Time         `boil:"record_end_date" json:"record_end_date,omitempty" toml:"record_end_date" yaml:"record_end_date,omitempty"`
	RecordEndQuantity   types.NullDecimal `boil:"record_end_quantity" json:"record_end_quantity,omitempty" toml:"record_end_quantity" yaml:"record_end_quantity,omitempty"`
	QuantityReserved    types.NullDecimal `boil:"quantity_reserved" json:"quantity_reserved,omitempty" toml:"quantity_reserved" yaml:"quantity_reserved,omitempty"`
	QuantityAvailable   types.NullDecimal `boil:"quantity_available" json:"quantity_available,omitempty" toml:"quantity_available" yaml:"quantity_available,omitempty"`
	QuantityReturned    types.NullDecimal `boil:"quantity_returned" json:"quantity_returned,omitempty" toml:"quantity_returned" yaml:"quantity_returned,omitempty"`
	TotalQuantityOnHand types.NullDecimal `boil:"total_quantity_on_hand" json:"total_quantity_on_hand,omitempty" toml:"total_quantity_on_hand" yaml:"total_quantity_on_hand,omitempty"`
	CostPerUnit         types.NullDecimal `boil:"cost_per_unit" json:"cost_per_unit,omitempty" toml:"cost_per_unit" yaml:"cost_per_unit,omitempty"`
	TotalValueOnHand    types.NullDecimal `boil:"total_value_on_hand" json:"total_value_on_hand,omitempty" toml:"total_value_on_hand" yaml:"total_value_on_hand,omitempty"`
	ReorderLevel        types.NullDecimal `boil:"reorder_level" json:"reorder_level,omitempty" toml:"reorder_level" yaml:"reorder_level,omitempty"`
	ReorderQuantity     types.NullDecimal `boil:"reorder_quantity" json:"reorder_quantity,omitempty" toml:"reorder_quantity" yaml:"reorder_quantity,omitempty"`
	IsDiscontinued      null.Bool         `boil:"is_discontinued" json:"is_discontinued,omitempty" toml:"is_discontinued" yaml:"is_discontinued,omitempty"`
	Remarks             null.String       `boil:"remarks" json:"remarks,omitempty" toml:"remarks" yaml:"remarks,omitempty"`
	CreatedAt           time.Time         `boil:"created_at" json:"created_at" toml:"created_at" yaml:"created_at"`
	UpdatedAt           time.Time         `boil:"updated_at" json:"updated_at" toml:"updated_at" yaml:"updated_at"`
	DeletedAt           null.Time         `boil:"deleted_at" json:"deleted_at,omitempty" toml:"deleted_at" yaml:"deleted_at,omitempty"`

	R *inventoryR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L inventoryL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var InventoryColumns = struct {
	ID                  string
	InventoryNumber     string
	ItemID              string
	RecordStartDate     string
	RecordStartQuantity string
	RecordEndDate       string
	RecordEndQuantity   string
	QuantityReserved    string
	QuantityAvailable   string
	QuantityReturned    string
	TotalQuantityOnHand string
	CostPerUnit         string
	TotalValueOnHand    string
	ReorderLevel        string
	ReorderQuantity     string
	IsDiscontinued      string
	Remarks             string
	CreatedAt           string
	UpdatedAt           string
	DeletedAt           string
}{
	ID:                  "id",
	InventoryNumber:     "inventory_number",
	ItemID:              "item_id",
	RecordStartDate:     "record_start_date",
	RecordStartQuantity: "record_start_quantity",
	RecordEndDate:       "record_end_date",
	RecordEndQuantity:   "record_end_quantity",
	QuantityReserved:    "quantity_reserved",
	QuantityAvailable:   "quantity_available",
	QuantityReturned:    "quantity_returned",
	TotalQuantityOnHand: "total_quantity_on_hand",
	CostPerUnit:         "cost_per_unit",
	TotalValueOnHand:    "total_value_on_hand",
	ReorderLevel:        "reorder_level",
	ReorderQuantity:     "reorder_quantity",
	IsDiscontinued:      "is_discontinued",
	Remarks:             "remarks",
	CreatedAt:           "created_at",
	UpdatedAt:           "updated_at",
	DeletedAt:           "deleted_at",
}

var InventoryTableColumns = struct {
	ID                  string
	InventoryNumber     string
	ItemID              string
	RecordStartDate     string
	RecordStartQuantity string
	RecordEndDate       string
	RecordEndQuantity   string
	QuantityReserved    string
	QuantityAvailable   string
	QuantityReturned    string
	TotalQuantityOnHand string
	CostPerUnit         string
	TotalValueOnHand    string
	ReorderLevel        string
	ReorderQuantity     string
	IsDiscontinued      string
	Remarks             string
	CreatedAt           string
	UpdatedAt           string
	DeletedAt           string
}{
	ID:                  "inventory.id",
	InventoryNumber:     "inventory.inventory_number",
	ItemID:              "inventory.item_id",
	RecordStartDate:     "inventory.record_start_date",
	RecordStartQuantity: "inventory.record_start_quantity",
	RecordEndDate:       "inventory.record_end_date",
	RecordEndQuantity:   "inventory.record_end_quantity",
	QuantityReserved:    "inventory.quantity_reserved",
	QuantityAvailable:   "inventory.quantity_available",
	QuantityReturned:    "inventory.quantity_returned",
	TotalQuantityOnHand: "inventory.total_quantity_on_hand",
	CostPerUnit:         "inventory.cost_per_unit",
	TotalValueOnHand:    "inventory.total_value_on_hand",
	ReorderLevel:        "inventory.reorder_level",
	ReorderQuantity:     "inventory.reorder_quantity",
	IsDiscontinued:      "inventory.is_discontinued",
	Remarks:             "inventory.remarks",
	CreatedAt:           "inventory.created_at",
	UpdatedAt:           "inventory.updated_at",
	DeletedAt:           "inventory.deleted_at",
}

// Generated where

type whereHelpertypes_NullDecimal struct{ field string }

func (w whereHelpertypes_NullDecimal) EQ(x types.NullDecimal) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpertypes_NullDecimal) NEQ(x types.NullDecimal) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpertypes_NullDecimal) LT(x types.NullDecimal) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpertypes_NullDecimal) LTE(x types.NullDecimal) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpertypes_NullDecimal) GT(x types.NullDecimal) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpertypes_NullDecimal) GTE(x types.NullDecimal) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

func (w whereHelpertypes_NullDecimal) IsNull() qm.QueryMod { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpertypes_NullDecimal) IsNotNull() qm.QueryMod {
	return qmhelper.WhereIsNotNull(w.field)
}

type whereHelpernull_Bool struct{ field string }

func (w whereHelpernull_Bool) EQ(x null.Bool) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_Bool) NEQ(x null.Bool) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_Bool) LT(x null.Bool) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_Bool) LTE(x null.Bool) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_Bool) GT(x null.Bool) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_Bool) GTE(x null.Bool) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

func (w whereHelpernull_Bool) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_Bool) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }

var InventoryWhere = struct {
	ID                  whereHelperint
	InventoryNumber     whereHelperstring
	ItemID              whereHelpernull_Int
	RecordStartDate     whereHelpernull_Time
	RecordStartQuantity whereHelpertypes_NullDecimal
	RecordEndDate       whereHelpernull_Time
	RecordEndQuantity   whereHelpertypes_NullDecimal
	QuantityReserved    whereHelpertypes_NullDecimal
	QuantityAvailable   whereHelpertypes_NullDecimal
	QuantityReturned    whereHelpertypes_NullDecimal
	TotalQuantityOnHand whereHelpertypes_NullDecimal
	CostPerUnit         whereHelpertypes_NullDecimal
	TotalValueOnHand    whereHelpertypes_NullDecimal
	ReorderLevel        whereHelpertypes_NullDecimal
	ReorderQuantity     whereHelpertypes_NullDecimal
	IsDiscontinued      whereHelpernull_Bool
	Remarks             whereHelpernull_String
	CreatedAt           whereHelpertime_Time
	UpdatedAt           whereHelpertime_Time
	DeletedAt           whereHelpernull_Time
}{
	ID:                  whereHelperint{field: "\"inventory\".\"inventory\".\"id\""},
	InventoryNumber:     whereHelperstring{field: "\"inventory\".\"inventory\".\"inventory_number\""},
	ItemID:              whereHelpernull_Int{field: "\"inventory\".\"inventory\".\"item_id\""},
	RecordStartDate:     whereHelpernull_Time{field: "\"inventory\".\"inventory\".\"record_start_date\""},
	RecordStartQuantity: whereHelpertypes_NullDecimal{field: "\"inventory\".\"inventory\".\"record_start_quantity\""},
	RecordEndDate:       whereHelpernull_Time{field: "\"inventory\".\"inventory\".\"record_end_date\""},
	RecordEndQuantity:   whereHelpertypes_NullDecimal{field: "\"inventory\".\"inventory\".\"record_end_quantity\""},
	QuantityReserved:    whereHelpertypes_NullDecimal{field: "\"inventory\".\"inventory\".\"quantity_reserved\""},
	QuantityAvailable:   whereHelpertypes_NullDecimal{field: "\"inventory\".\"inventory\".\"quantity_available\""},
	QuantityReturned:    whereHelpertypes_NullDecimal{field: "\"inventory\".\"inventory\".\"quantity_returned\""},
	TotalQuantityOnHand: whereHelpertypes_NullDecimal{field: "\"inventory\".\"inventory\".\"total_quantity_on_hand\""},
	CostPerUnit:         whereHelpertypes_NullDecimal{field: "\"inventory\".\"inventory\".\"cost_per_unit\""},
	TotalValueOnHand:    whereHelpertypes_NullDecimal{field: "\"inventory\".\"inventory\".\"total_value_on_hand\""},
	ReorderLevel:        whereHelpertypes_NullDecimal{field: "\"inventory\".\"inventory\".\"reorder_level\""},
	ReorderQuantity:     whereHelpertypes_NullDecimal{field: "\"inventory\".\"inventory\".\"reorder_quantity\""},
	IsDiscontinued:      whereHelpernull_Bool{field: "\"inventory\".\"inventory\".\"is_discontinued\""},
	Remarks:             whereHelpernull_String{field: "\"inventory\".\"inventory\".\"remarks\""},
	CreatedAt:           whereHelpertime_Time{field: "\"inventory\".\"inventory\".\"created_at\""},
	UpdatedAt:           whereHelpertime_Time{field: "\"inventory\".\"inventory\".\"updated_at\""},
	DeletedAt:           whereHelpernull_Time{field: "\"inventory\".\"inventory\".\"deleted_at\""},
}

// InventoryRels is where relationship names are stored.
var InventoryRels = struct {
	GoodsIssueNoteItems                 string
	InventoryTransactions               string
	ReturnMerchandiseAuthorizationItems string
	StockCountSheets                    string
}{
	GoodsIssueNoteItems:                 "GoodsIssueNoteItems",
	InventoryTransactions:               "InventoryTransactions",
	ReturnMerchandiseAuthorizationItems: "ReturnMerchandiseAuthorizationItems",
	StockCountSheets:                    "StockCountSheets",
}

// inventoryR is where relationships are stored.
type inventoryR struct {
	GoodsIssueNoteItems                 GoodsIssueNoteItemSlice                 `boil:"GoodsIssueNoteItems" json:"GoodsIssueNoteItems" toml:"GoodsIssueNoteItems" yaml:"GoodsIssueNoteItems"`
	InventoryTransactions               InventoryTransactionSlice               `boil:"InventoryTransactions" json:"InventoryTransactions" toml:"InventoryTransactions" yaml:"InventoryTransactions"`
	ReturnMerchandiseAuthorizationItems ReturnMerchandiseAuthorizationItemSlice `boil:"ReturnMerchandiseAuthorizationItems" json:"ReturnMerchandiseAuthorizationItems" toml:"ReturnMerchandiseAuthorizationItems" yaml:"ReturnMerchandiseAuthorizationItems"`
	StockCountSheets                    StockCountSheetSlice                    `boil:"StockCountSheets" json:"StockCountSheets" toml:"StockCountSheets" yaml:"StockCountSheets"`
}

// NewStruct creates a new relationship struct
func (*inventoryR) NewStruct() *inventoryR {
	return &inventoryR{}
}

func (r *inventoryR) GetGoodsIssueNoteItems() GoodsIssueNoteItemSlice {
	if r == nil {
		return nil
	}
	return r.GoodsIssueNoteItems
}

func (r *inventoryR) GetInventoryTransactions() InventoryTransactionSlice {
	if r == nil {
		return nil
	}
	return r.InventoryTransactions
}

func (r *inventoryR) GetReturnMerchandiseAuthorizationItems() ReturnMerchandiseAuthorizationItemSlice {
	if r == nil {
		return nil
	}
	return r.ReturnMerchandiseAuthorizationItems
}

func (r *inventoryR) GetStockCountSheets() StockCountSheetSlice {
	if r == nil {
		return nil
	}
	return r.StockCountSheets
}

// inventoryL is where Load methods for each relationship are stored.
type inventoryL struct{}

var (
	inventoryAllColumns            = []string{"id", "inventory_number", "item_id", "record_start_date", "record_start_quantity", "record_end_date", "record_end_quantity", "quantity_reserved", "quantity_available", "quantity_returned", "total_quantity_on_hand", "cost_per_unit", "total_value_on_hand", "reorder_level", "reorder_quantity", "is_discontinued", "remarks", "created_at", "updated_at", "deleted_at"}
	inventoryColumnsWithoutDefault = []string{"id", "inventory_number", "created_at", "updated_at"}
	inventoryColumnsWithDefault    = []string{"item_id", "record_start_date", "record_start_quantity", "record_end_date", "record_end_quantity", "quantity_reserved", "quantity_available", "quantity_returned", "total_quantity_on_hand", "cost_per_unit", "total_value_on_hand", "reorder_level", "reorder_quantity", "is_discontinued", "remarks", "deleted_at"}
	inventoryPrimaryKeyColumns     = []string{"id"}
	inventoryGeneratedColumns      = []string{}
)

type (
	// InventorySlice is an alias for a slice of pointers to Inventory.
	// This should almost always be used instead of []Inventory.
	InventorySlice []*Inventory
	// InventoryHook is the signature for custom Inventory hook methods
	InventoryHook func(context.Context, boil.ContextExecutor, *Inventory) error

	inventoryQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	inventoryType                 = reflect.TypeOf(&Inventory{})
	inventoryMapping              = queries.MakeStructMapping(inventoryType)
	inventoryPrimaryKeyMapping, _ = queries.BindMapping(inventoryType, inventoryMapping, inventoryPrimaryKeyColumns)
	inventoryInsertCacheMut       sync.RWMutex
	inventoryInsertCache          = make(map[string]insertCache)
	inventoryUpdateCacheMut       sync.RWMutex
	inventoryUpdateCache          = make(map[string]updateCache)
	inventoryUpsertCacheMut       sync.RWMutex
	inventoryUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var inventoryAfterSelectMu sync.Mutex
var inventoryAfterSelectHooks []InventoryHook

var inventoryBeforeInsertMu sync.Mutex
var inventoryBeforeInsertHooks []InventoryHook
var inventoryAfterInsertMu sync.Mutex
var inventoryAfterInsertHooks []InventoryHook

var inventoryBeforeUpdateMu sync.Mutex
var inventoryBeforeUpdateHooks []InventoryHook
var inventoryAfterUpdateMu sync.Mutex
var inventoryAfterUpdateHooks []InventoryHook

var inventoryBeforeDeleteMu sync.Mutex
var inventoryBeforeDeleteHooks []InventoryHook
var inventoryAfterDeleteMu sync.Mutex
var inventoryAfterDeleteHooks []InventoryHook

var inventoryBeforeUpsertMu sync.Mutex
var inventoryBeforeUpsertHooks []InventoryHook
var inventoryAfterUpsertMu sync.Mutex
var inventoryAfterUpsertHooks []InventoryHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *Inventory) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range inventoryAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *Inventory) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range inventoryBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *Inventory) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range inventoryAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *Inventory) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range inventoryBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *Inventory) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range inventoryAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *Inventory) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range inventoryBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *Inventory) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range inventoryAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *Inventory) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range inventoryBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *Inventory) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range inventoryAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddInventoryHook registers your hook function for all future operations.
func AddInventoryHook(hookPoint boil.HookPoint, inventoryHook InventoryHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		inventoryAfterSelectMu.Lock()
		inventoryAfterSelectHooks = append(inventoryAfterSelectHooks, inventoryHook)
		inventoryAfterSelectMu.Unlock()
	case boil.BeforeInsertHook:
		inventoryBeforeInsertMu.Lock()
		inventoryBeforeInsertHooks = append(inventoryBeforeInsertHooks, inventoryHook)
		inventoryBeforeInsertMu.Unlock()
	case boil.AfterInsertHook:
		inventoryAfterInsertMu.Lock()
		inventoryAfterInsertHooks = append(inventoryAfterInsertHooks, inventoryHook)
		inventoryAfterInsertMu.Unlock()
	case boil.BeforeUpdateHook:
		inventoryBeforeUpdateMu.Lock()
		inventoryBeforeUpdateHooks = append(inventoryBeforeUpdateHooks, inventoryHook)
		inventoryBeforeUpdateMu.Unlock()
	case boil.AfterUpdateHook:
		inventoryAfterUpdateMu.Lock()
		inventoryAfterUpdateHooks = append(inventoryAfterUpdateHooks, inventoryHook)
		inventoryAfterUpdateMu.Unlock()
	case boil.BeforeDeleteHook:
		inventoryBeforeDeleteMu.Lock()
		inventoryBeforeDeleteHooks = append(inventoryBeforeDeleteHooks, inventoryHook)
		inventoryBeforeDeleteMu.Unlock()
	case boil.AfterDeleteHook:
		inventoryAfterDeleteMu.Lock()
		inventoryAfterDeleteHooks = append(inventoryAfterDeleteHooks, inventoryHook)
		inventoryAfterDeleteMu.Unlock()
	case boil.BeforeUpsertHook:
		inventoryBeforeUpsertMu.Lock()
		inventoryBeforeUpsertHooks = append(inventoryBeforeUpsertHooks, inventoryHook)
		inventoryBeforeUpsertMu.Unlock()
	case boil.AfterUpsertHook:
		inventoryAfterUpsertMu.Lock()
		inventoryAfterUpsertHooks = append(inventoryAfterUpsertHooks, inventoryHook)
		inventoryAfterUpsertMu.Unlock()
	}
}

// One returns a single inventory record from the query.
func (q inventoryQuery) One(ctx context.Context, exec boil.ContextExecutor) (*Inventory, error) {
	o := &Inventory{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "inventory: failed to execute a one query for inventory")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all Inventory records from the query.
func (q inventoryQuery) All(ctx context.Context, exec boil.ContextExecutor) (InventorySlice, error) {
	var o []*Inventory

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "inventory: failed to assign all query results to Inventory slice")
	}

	if len(inventoryAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all Inventory records in the query.
func (q inventoryQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "inventory: failed to count inventory rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q inventoryQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "inventory: failed to check if inventory exists")
	}

	return count > 0, nil
}

// GoodsIssueNoteItems retrieves all the goods_issue_note_item's GoodsIssueNoteItems with an executor.
func (o *Inventory) GoodsIssueNoteItems(mods ...qm.QueryMod) goodsIssueNoteItemQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"inventory\".\"goods_issue_note_item\".\"inventory_id\"=?", o.ID),
	)

	return GoodsIssueNoteItems(queryMods...)
}

// InventoryTransactions retrieves all the inventory_transaction's InventoryTransactions with an executor.
func (o *Inventory) InventoryTransactions(mods ...qm.QueryMod) inventoryTransactionQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"inventory\".\"inventory_transaction\".\"inventory_id\"=?", o.ID),
	)

	return InventoryTransactions(queryMods...)
}

// ReturnMerchandiseAuthorizationItems retrieves all the return_merchandise_authorization_item's ReturnMerchandiseAuthorizationItems with an executor.
func (o *Inventory) ReturnMerchandiseAuthorizationItems(mods ...qm.QueryMod) returnMerchandiseAuthorizationItemQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"inventory\".\"return_merchandise_authorization_item\".\"inventory_id\"=?", o.ID),
	)

	return ReturnMerchandiseAuthorizationItems(queryMods...)
}

// StockCountSheets retrieves all the stock_count_sheet's StockCountSheets with an executor.
func (o *Inventory) StockCountSheets(mods ...qm.QueryMod) stockCountSheetQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"inventory\".\"stock_count_sheet\".\"inventory_id\"=?", o.ID),
	)

	return StockCountSheets(queryMods...)
}

// LoadGoodsIssueNoteItems allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (inventoryL) LoadGoodsIssueNoteItems(ctx context.Context, e boil.ContextExecutor, singular bool, maybeInventory interface{}, mods queries.Applicator) error {
	var slice []*Inventory
	var object *Inventory

	if singular {
		var ok bool
		object, ok = maybeInventory.(*Inventory)
		if !ok {
			object = new(Inventory)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeInventory)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeInventory))
			}
		}
	} else {
		s, ok := maybeInventory.(*[]*Inventory)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeInventory)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeInventory))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &inventoryR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &inventoryR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`inventory.goods_issue_note_item`),
		qm.WhereIn(`inventory.goods_issue_note_item.inventory_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load goods_issue_note_item")
	}

	var resultSlice []*GoodsIssueNoteItem
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice goods_issue_note_item")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on goods_issue_note_item")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for goods_issue_note_item")
	}

	if len(goodsIssueNoteItemAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.GoodsIssueNoteItems = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &goodsIssueNoteItemR{}
			}
			foreign.R.Inventory = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.InventoryID) {
				local.R.GoodsIssueNoteItems = append(local.R.GoodsIssueNoteItems, foreign)
				if foreign.R == nil {
					foreign.R = &goodsIssueNoteItemR{}
				}
				foreign.R.Inventory = local
				break
			}
		}
	}

	return nil
}

// LoadInventoryTransactions allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (inventoryL) LoadInventoryTransactions(ctx context.Context, e boil.ContextExecutor, singular bool, maybeInventory interface{}, mods queries.Applicator) error {
	var slice []*Inventory
	var object *Inventory

	if singular {
		var ok bool
		object, ok = maybeInventory.(*Inventory)
		if !ok {
			object = new(Inventory)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeInventory)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeInventory))
			}
		}
	} else {
		s, ok := maybeInventory.(*[]*Inventory)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeInventory)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeInventory))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &inventoryR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &inventoryR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`inventory.inventory_transaction`),
		qm.WhereIn(`inventory.inventory_transaction.inventory_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load inventory_transaction")
	}

	var resultSlice []*InventoryTransaction
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice inventory_transaction")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on inventory_transaction")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for inventory_transaction")
	}

	if len(inventoryTransactionAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.InventoryTransactions = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &inventoryTransactionR{}
			}
			foreign.R.Inventory = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.InventoryID) {
				local.R.InventoryTransactions = append(local.R.InventoryTransactions, foreign)
				if foreign.R == nil {
					foreign.R = &inventoryTransactionR{}
				}
				foreign.R.Inventory = local
				break
			}
		}
	}

	return nil
}

// LoadReturnMerchandiseAuthorizationItems allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (inventoryL) LoadReturnMerchandiseAuthorizationItems(ctx context.Context, e boil.ContextExecutor, singular bool, maybeInventory interface{}, mods queries.Applicator) error {
	var slice []*Inventory
	var object *Inventory

	if singular {
		var ok bool
		object, ok = maybeInventory.(*Inventory)
		if !ok {
			object = new(Inventory)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeInventory)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeInventory))
			}
		}
	} else {
		s, ok := maybeInventory.(*[]*Inventory)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeInventory)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeInventory))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &inventoryR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &inventoryR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`inventory.return_merchandise_authorization_item`),
		qm.WhereIn(`inventory.return_merchandise_authorization_item.inventory_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load return_merchandise_authorization_item")
	}

	var resultSlice []*ReturnMerchandiseAuthorizationItem
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice return_merchandise_authorization_item")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on return_merchandise_authorization_item")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for return_merchandise_authorization_item")
	}

	if len(returnMerchandiseAuthorizationItemAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.ReturnMerchandiseAuthorizationItems = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &returnMerchandiseAuthorizationItemR{}
			}
			foreign.R.Inventory = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.InventoryID) {
				local.R.ReturnMerchandiseAuthorizationItems = append(local.R.ReturnMerchandiseAuthorizationItems, foreign)
				if foreign.R == nil {
					foreign.R = &returnMerchandiseAuthorizationItemR{}
				}
				foreign.R.Inventory = local
				break
			}
		}
	}

	return nil
}

// LoadStockCountSheets allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (inventoryL) LoadStockCountSheets(ctx context.Context, e boil.ContextExecutor, singular bool, maybeInventory interface{}, mods queries.Applicator) error {
	var slice []*Inventory
	var object *Inventory

	if singular {
		var ok bool
		object, ok = maybeInventory.(*Inventory)
		if !ok {
			object = new(Inventory)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeInventory)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeInventory))
			}
		}
	} else {
		s, ok := maybeInventory.(*[]*Inventory)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeInventory)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeInventory))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &inventoryR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &inventoryR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`inventory.stock_count_sheet`),
		qm.WhereIn(`inventory.stock_count_sheet.inventory_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load stock_count_sheet")
	}

	var resultSlice []*StockCountSheet
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice stock_count_sheet")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on stock_count_sheet")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for stock_count_sheet")
	}

	if len(stockCountSheetAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.StockCountSheets = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &stockCountSheetR{}
			}
			foreign.R.Inventory = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.InventoryID) {
				local.R.StockCountSheets = append(local.R.StockCountSheets, foreign)
				if foreign.R == nil {
					foreign.R = &stockCountSheetR{}
				}
				foreign.R.Inventory = local
				break
			}
		}
	}

	return nil
}

// AddGoodsIssueNoteItems adds the given related objects to the existing relationships
// of the inventory, optionally inserting them as new records.
// Appends related to o.R.GoodsIssueNoteItems.
// Sets related.R.Inventory appropriately.
func (o *Inventory) AddGoodsIssueNoteItems(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*GoodsIssueNoteItem) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.InventoryID, o.ID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"inventory\".\"goods_issue_note_item\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"inventory_id"}),
				strmangle.WhereClause("\"", "\"", 2, goodsIssueNoteItemPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.InventoryID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &inventoryR{
			GoodsIssueNoteItems: related,
		}
	} else {
		o.R.GoodsIssueNoteItems = append(o.R.GoodsIssueNoteItems, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &goodsIssueNoteItemR{
				Inventory: o,
			}
		} else {
			rel.R.Inventory = o
		}
	}
	return nil
}

// SetGoodsIssueNoteItems removes all previously related items of the
// inventory replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Inventory's GoodsIssueNoteItems accordingly.
// Replaces o.R.GoodsIssueNoteItems with related.
// Sets related.R.Inventory's GoodsIssueNoteItems accordingly.
func (o *Inventory) SetGoodsIssueNoteItems(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*GoodsIssueNoteItem) error {
	query := "update \"inventory\".\"goods_issue_note_item\" set \"inventory_id\" = null where \"inventory_id\" = $1"
	values := []interface{}{o.ID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.GoodsIssueNoteItems {
			queries.SetScanner(&rel.InventoryID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Inventory = nil
		}
		o.R.GoodsIssueNoteItems = nil
	}

	return o.AddGoodsIssueNoteItems(ctx, exec, insert, related...)
}

// RemoveGoodsIssueNoteItems relationships from objects passed in.
// Removes related items from R.GoodsIssueNoteItems (uses pointer comparison, removal does not keep order)
// Sets related.R.Inventory.
func (o *Inventory) RemoveGoodsIssueNoteItems(ctx context.Context, exec boil.ContextExecutor, related ...*GoodsIssueNoteItem) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.InventoryID, nil)
		if rel.R != nil {
			rel.R.Inventory = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("inventory_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.GoodsIssueNoteItems {
			if rel != ri {
				continue
			}

			ln := len(o.R.GoodsIssueNoteItems)
			if ln > 1 && i < ln-1 {
				o.R.GoodsIssueNoteItems[i] = o.R.GoodsIssueNoteItems[ln-1]
			}
			o.R.GoodsIssueNoteItems = o.R.GoodsIssueNoteItems[:ln-1]
			break
		}
	}

	return nil
}

// AddInventoryTransactions adds the given related objects to the existing relationships
// of the inventory, optionally inserting them as new records.
// Appends related to o.R.InventoryTransactions.
// Sets related.R.Inventory appropriately.
func (o *Inventory) AddInventoryTransactions(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*InventoryTransaction) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.InventoryID, o.ID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"inventory\".\"inventory_transaction\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"inventory_id"}),
				strmangle.WhereClause("\"", "\"", 2, inventoryTransactionPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.InventoryID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &inventoryR{
			InventoryTransactions: related,
		}
	} else {
		o.R.InventoryTransactions = append(o.R.InventoryTransactions, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &inventoryTransactionR{
				Inventory: o,
			}
		} else {
			rel.R.Inventory = o
		}
	}
	return nil
}

// SetInventoryTransactions removes all previously related items of the
// inventory replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Inventory's InventoryTransactions accordingly.
// Replaces o.R.InventoryTransactions with related.
// Sets related.R.Inventory's InventoryTransactions accordingly.
func (o *Inventory) SetInventoryTransactions(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*InventoryTransaction) error {
	query := "update \"inventory\".\"inventory_transaction\" set \"inventory_id\" = null where \"inventory_id\" = $1"
	values := []interface{}{o.ID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.InventoryTransactions {
			queries.SetScanner(&rel.InventoryID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Inventory = nil
		}
		o.R.InventoryTransactions = nil
	}

	return o.AddInventoryTransactions(ctx, exec, insert, related...)
}

// RemoveInventoryTransactions relationships from objects passed in.
// Removes related items from R.InventoryTransactions (uses pointer comparison, removal does not keep order)
// Sets related.R.Inventory.
func (o *Inventory) RemoveInventoryTransactions(ctx context.Context, exec boil.ContextExecutor, related ...*InventoryTransaction) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.InventoryID, nil)
		if rel.R != nil {
			rel.R.Inventory = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("inventory_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.InventoryTransactions {
			if rel != ri {
				continue
			}

			ln := len(o.R.InventoryTransactions)
			if ln > 1 && i < ln-1 {
				o.R.InventoryTransactions[i] = o.R.InventoryTransactions[ln-1]
			}
			o.R.InventoryTransactions = o.R.InventoryTransactions[:ln-1]
			break
		}
	}

	return nil
}

// AddReturnMerchandiseAuthorizationItems adds the given related objects to the existing relationships
// of the inventory, optionally inserting them as new records.
// Appends related to o.R.ReturnMerchandiseAuthorizationItems.
// Sets related.R.Inventory appropriately.
func (o *Inventory) AddReturnMerchandiseAuthorizationItems(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*ReturnMerchandiseAuthorizationItem) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.InventoryID, o.ID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"inventory\".\"return_merchandise_authorization_item\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"inventory_id"}),
				strmangle.WhereClause("\"", "\"", 2, returnMerchandiseAuthorizationItemPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.InventoryID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &inventoryR{
			ReturnMerchandiseAuthorizationItems: related,
		}
	} else {
		o.R.ReturnMerchandiseAuthorizationItems = append(o.R.ReturnMerchandiseAuthorizationItems, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &returnMerchandiseAuthorizationItemR{
				Inventory: o,
			}
		} else {
			rel.R.Inventory = o
		}
	}
	return nil
}

// SetReturnMerchandiseAuthorizationItems removes all previously related items of the
// inventory replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Inventory's ReturnMerchandiseAuthorizationItems accordingly.
// Replaces o.R.ReturnMerchandiseAuthorizationItems with related.
// Sets related.R.Inventory's ReturnMerchandiseAuthorizationItems accordingly.
func (o *Inventory) SetReturnMerchandiseAuthorizationItems(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*ReturnMerchandiseAuthorizationItem) error {
	query := "update \"inventory\".\"return_merchandise_authorization_item\" set \"inventory_id\" = null where \"inventory_id\" = $1"
	values := []interface{}{o.ID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.ReturnMerchandiseAuthorizationItems {
			queries.SetScanner(&rel.InventoryID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Inventory = nil
		}
		o.R.ReturnMerchandiseAuthorizationItems = nil
	}

	return o.AddReturnMerchandiseAuthorizationItems(ctx, exec, insert, related...)
}

// RemoveReturnMerchandiseAuthorizationItems relationships from objects passed in.
// Removes related items from R.ReturnMerchandiseAuthorizationItems (uses pointer comparison, removal does not keep order)
// Sets related.R.Inventory.
func (o *Inventory) RemoveReturnMerchandiseAuthorizationItems(ctx context.Context, exec boil.ContextExecutor, related ...*ReturnMerchandiseAuthorizationItem) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.InventoryID, nil)
		if rel.R != nil {
			rel.R.Inventory = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("inventory_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.ReturnMerchandiseAuthorizationItems {
			if rel != ri {
				continue
			}

			ln := len(o.R.ReturnMerchandiseAuthorizationItems)
			if ln > 1 && i < ln-1 {
				o.R.ReturnMerchandiseAuthorizationItems[i] = o.R.ReturnMerchandiseAuthorizationItems[ln-1]
			}
			o.R.ReturnMerchandiseAuthorizationItems = o.R.ReturnMerchandiseAuthorizationItems[:ln-1]
			break
		}
	}

	return nil
}

// AddStockCountSheets adds the given related objects to the existing relationships
// of the inventory, optionally inserting them as new records.
// Appends related to o.R.StockCountSheets.
// Sets related.R.Inventory appropriately.
func (o *Inventory) AddStockCountSheets(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*StockCountSheet) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.InventoryID, o.ID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"inventory\".\"stock_count_sheet\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"inventory_id"}),
				strmangle.WhereClause("\"", "\"", 2, stockCountSheetPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.InventoryID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &inventoryR{
			StockCountSheets: related,
		}
	} else {
		o.R.StockCountSheets = append(o.R.StockCountSheets, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &stockCountSheetR{
				Inventory: o,
			}
		} else {
			rel.R.Inventory = o
		}
	}
	return nil
}

// SetStockCountSheets removes all previously related items of the
// inventory replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Inventory's StockCountSheets accordingly.
// Replaces o.R.StockCountSheets with related.
// Sets related.R.Inventory's StockCountSheets accordingly.
func (o *Inventory) SetStockCountSheets(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*StockCountSheet) error {
	query := "update \"inventory\".\"stock_count_sheet\" set \"inventory_id\" = null where \"inventory_id\" = $1"
	values := []interface{}{o.ID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.StockCountSheets {
			queries.SetScanner(&rel.InventoryID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Inventory = nil
		}
		o.R.StockCountSheets = nil
	}

	return o.AddStockCountSheets(ctx, exec, insert, related...)
}

// RemoveStockCountSheets relationships from objects passed in.
// Removes related items from R.StockCountSheets (uses pointer comparison, removal does not keep order)
// Sets related.R.Inventory.
func (o *Inventory) RemoveStockCountSheets(ctx context.Context, exec boil.ContextExecutor, related ...*StockCountSheet) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.InventoryID, nil)
		if rel.R != nil {
			rel.R.Inventory = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("inventory_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.StockCountSheets {
			if rel != ri {
				continue
			}

			ln := len(o.R.StockCountSheets)
			if ln > 1 && i < ln-1 {
				o.R.StockCountSheets[i] = o.R.StockCountSheets[ln-1]
			}
			o.R.StockCountSheets = o.R.StockCountSheets[:ln-1]
			break
		}
	}

	return nil
}

// Inventories retrieves all the records using an executor.
func Inventories(mods ...qm.QueryMod) inventoryQuery {
	mods = append(mods, qm.From("\"inventory\".\"inventory\""))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"\"inventory\".\"inventory\".*"})
	}

	return inventoryQuery{q}
}

// FindInventory retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindInventory(ctx context.Context, exec boil.ContextExecutor, iD int, selectCols ...string) (*Inventory, error) {
	inventoryObj := &Inventory{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"inventory\".\"inventory\" where \"id\"=$1", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, inventoryObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "inventory: unable to select from inventory")
	}

	if err = inventoryObj.doAfterSelectHooks(ctx, exec); err != nil {
		return inventoryObj, err
	}

	return inventoryObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *Inventory) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("inventory: no inventory provided for insertion")
	}

	var err error
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
		if o.UpdatedAt.IsZero() {
			o.UpdatedAt = currTime
		}
	}

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(inventoryColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	inventoryInsertCacheMut.RLock()
	cache, cached := inventoryInsertCache[key]
	inventoryInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			inventoryAllColumns,
			inventoryColumnsWithDefault,
			inventoryColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(inventoryType, inventoryMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(inventoryType, inventoryMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"inventory\".\"inventory\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"inventory\".\"inventory\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "inventory: unable to insert into inventory")
	}

	if !cached {
		inventoryInsertCacheMut.Lock()
		inventoryInsertCache[key] = cache
		inventoryInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the Inventory.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *Inventory) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		o.UpdatedAt = currTime
	}

	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	inventoryUpdateCacheMut.RLock()
	cache, cached := inventoryUpdateCache[key]
	inventoryUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			inventoryAllColumns,
			inventoryPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("inventory: unable to update inventory, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"inventory\".\"inventory\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, inventoryPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(inventoryType, inventoryMapping, append(wl, inventoryPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "inventory: unable to update inventory row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "inventory: failed to get rows affected by update for inventory")
	}

	if !cached {
		inventoryUpdateCacheMut.Lock()
		inventoryUpdateCache[key] = cache
		inventoryUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q inventoryQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "inventory: unable to update all for inventory")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "inventory: unable to retrieve rows affected for inventory")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o InventorySlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("inventory: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), inventoryPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"inventory\".\"inventory\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, inventoryPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "inventory: unable to update all in inventory slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "inventory: unable to retrieve rows affected all in update all inventory")
	}
	return rowsAff, nil
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *Inventory) Upsert(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns, opts ...UpsertOptionFunc) error {
	if o == nil {
		return errors.New("inventory: no inventory provided for upsert")
	}
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
		o.UpdatedAt = currTime
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(inventoryColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	inventoryUpsertCacheMut.RLock()
	cache, cached := inventoryUpsertCache[key]
	inventoryUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, _ := insertColumns.InsertColumnSet(
			inventoryAllColumns,
			inventoryColumnsWithDefault,
			inventoryColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			inventoryAllColumns,
			inventoryPrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("inventory: unable to upsert inventory, could not build update column list")
		}

		ret := strmangle.SetComplement(inventoryAllColumns, strmangle.SetIntersect(insert, update))

		conflict := conflictColumns
		if len(conflict) == 0 && updateOnConflict && len(update) != 0 {
			if len(inventoryPrimaryKeyColumns) == 0 {
				return errors.New("inventory: unable to upsert inventory, could not build conflict column list")
			}

			conflict = make([]string, len(inventoryPrimaryKeyColumns))
			copy(conflict, inventoryPrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"inventory\".\"inventory\"", updateOnConflict, ret, update, conflict, insert, opts...)

		cache.valueMapping, err = queries.BindMapping(inventoryType, inventoryMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(inventoryType, inventoryMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
		if errors.Is(err, sql.ErrNoRows) {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "inventory: unable to upsert inventory")
	}

	if !cached {
		inventoryUpsertCacheMut.Lock()
		inventoryUpsertCache[key] = cache
		inventoryUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single Inventory record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *Inventory) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("inventory: no Inventory provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), inventoryPrimaryKeyMapping)
	sql := "DELETE FROM \"inventory\".\"inventory\" WHERE \"id\"=$1"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "inventory: unable to delete from inventory")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "inventory: failed to get rows affected by delete for inventory")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q inventoryQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("inventory: no inventoryQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "inventory: unable to delete all from inventory")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "inventory: failed to get rows affected by deleteall for inventory")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o InventorySlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(inventoryBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), inventoryPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"inventory\".\"inventory\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, inventoryPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "inventory: unable to delete all from inventory slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "inventory: failed to get rows affected by deleteall for inventory")
	}

	if len(inventoryAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *Inventory) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindInventory(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *InventorySlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := InventorySlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), inventoryPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"inventory\".\"inventory\".* FROM \"inventory\".\"inventory\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, inventoryPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "inventory: unable to reload all in InventorySlice")
	}

	*o = slice

	return nil
}

// InventoryExists checks if the Inventory row exists.
func InventoryExists(ctx context.Context, exec boil.ContextExecutor, iD int) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"inventory\".\"inventory\" where \"id\"=$1 limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, iD)
	}
	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "inventory: unable to check if inventory exists")
	}

	return exists, nil
}

// Exists checks if the Inventory row exists.
func (o *Inventory) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	return InventoryExists(ctx, exec, o.ID)
}
