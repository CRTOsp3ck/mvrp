// Code generated by SQLBoiler 4.16.2 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package sale

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// DeliveryNoteView is an object representing the database table.
type DeliveryNoteView struct {
	ID                           null.Int           `boil:"id" json:"id,omitempty" toml:"id" yaml:"id,omitempty"`
	BaseDocumentID               null.Int           `boil:"base_document_id" json:"base_document_id,omitempty" toml:"base_document_id" yaml:"base_document_id,omitempty"`
	DeliveryNoteNumber           null.String        `boil:"delivery_note_number" json:"delivery_note_number,omitempty" toml:"delivery_note_number" yaml:"delivery_note_number,omitempty"`
	SalesOrderID                 null.Int           `boil:"sales_order_id" json:"sales_order_id,omitempty" toml:"sales_order_id" yaml:"sales_order_id,omitempty"`
	VendorID                     null.Int           `boil:"vendor_id" json:"vendor_id,omitempty" toml:"vendor_id" yaml:"vendor_id,omitempty"`
	CustomerID                   null.Int           `boil:"customer_id" json:"customer_id,omitempty" toml:"customer_id" yaml:"customer_id,omitempty"`
	ShipToInformation            null.JSON          `boil:"ship_to_information" json:"ship_to_information,omitempty" toml:"ship_to_information" yaml:"ship_to_information,omitempty"`
	ShipFromInformation          null.JSON          `boil:"ship_from_information" json:"ship_from_information,omitempty" toml:"ship_from_information" yaml:"ship_from_information,omitempty"`
	BillToInformation            null.JSON          `boil:"bill_to_information" json:"bill_to_information,omitempty" toml:"bill_to_information" yaml:"bill_to_information,omitempty"`
	ShippingDate                 null.Time          `boil:"shipping_date" json:"shipping_date,omitempty" toml:"shipping_date" yaml:"shipping_date,omitempty"`
	ShippingPersonnelInformation null.JSON          `boil:"shipping_personnel_information" json:"shipping_personnel_information,omitempty" toml:"shipping_personnel_information" yaml:"shipping_personnel_information,omitempty"`
	ShippingStatus               NullShippingStatus `boil:"shipping_status" json:"shipping_status,omitempty" toml:"shipping_status" yaml:"shipping_status,omitempty"`
	ReceivedBy                   null.JSON          `boil:"received_by" json:"received_by,omitempty" toml:"received_by" yaml:"received_by,omitempty"`
	OverallGoodsCondition        null.String        `boil:"overall_goods_condition" json:"overall_goods_condition,omitempty" toml:"overall_goods_condition" yaml:"overall_goods_condition,omitempty"`
	CreatedAt                    null.Time          `boil:"created_at" json:"created_at,omitempty" toml:"created_at" yaml:"created_at,omitempty"`
	UpdatedAt                    null.Time          `boil:"updated_at" json:"updated_at,omitempty" toml:"updated_at" yaml:"updated_at,omitempty"`
	DeletedAt                    null.Time          `boil:"deleted_at" json:"deleted_at,omitempty" toml:"deleted_at" yaml:"deleted_at,omitempty"`
	BaseDocument                 null.JSON          `boil:"base_document" json:"base_document,omitempty" toml:"base_document" yaml:"base_document,omitempty"`
	VendorInfo                   null.JSON          `boil:"vendor_info" json:"vendor_info,omitempty" toml:"vendor_info" yaml:"vendor_info,omitempty"`
	CustomerInfo                 null.JSON          `boil:"customer_info" json:"customer_info,omitempty" toml:"customer_info" yaml:"customer_info,omitempty"`
	DeliveryNoteItems            null.JSON          `boil:"delivery_note_items" json:"delivery_note_items,omitempty" toml:"delivery_note_items" yaml:"delivery_note_items,omitempty"`
}

var DeliveryNoteViewColumns = struct {
	ID                           string
	BaseDocumentID               string
	DeliveryNoteNumber           string
	SalesOrderID                 string
	VendorID                     string
	CustomerID                   string
	ShipToInformation            string
	ShipFromInformation          string
	BillToInformation            string
	ShippingDate                 string
	ShippingPersonnelInformation string
	ShippingStatus               string
	ReceivedBy                   string
	OverallGoodsCondition        string
	CreatedAt                    string
	UpdatedAt                    string
	DeletedAt                    string
	BaseDocument                 string
	VendorInfo                   string
	CustomerInfo                 string
	DeliveryNoteItems            string
}{
	ID:                           "id",
	BaseDocumentID:               "base_document_id",
	DeliveryNoteNumber:           "delivery_note_number",
	SalesOrderID:                 "sales_order_id",
	VendorID:                     "vendor_id",
	CustomerID:                   "customer_id",
	ShipToInformation:            "ship_to_information",
	ShipFromInformation:          "ship_from_information",
	BillToInformation:            "bill_to_information",
	ShippingDate:                 "shipping_date",
	ShippingPersonnelInformation: "shipping_personnel_information",
	ShippingStatus:               "shipping_status",
	ReceivedBy:                   "received_by",
	OverallGoodsCondition:        "overall_goods_condition",
	CreatedAt:                    "created_at",
	UpdatedAt:                    "updated_at",
	DeletedAt:                    "deleted_at",
	BaseDocument:                 "base_document",
	VendorInfo:                   "vendor_info",
	CustomerInfo:                 "customer_info",
	DeliveryNoteItems:            "delivery_note_items",
}

var DeliveryNoteViewTableColumns = struct {
	ID                           string
	BaseDocumentID               string
	DeliveryNoteNumber           string
	SalesOrderID                 string
	VendorID                     string
	CustomerID                   string
	ShipToInformation            string
	ShipFromInformation          string
	BillToInformation            string
	ShippingDate                 string
	ShippingPersonnelInformation string
	ShippingStatus               string
	ReceivedBy                   string
	OverallGoodsCondition        string
	CreatedAt                    string
	UpdatedAt                    string
	DeletedAt                    string
	BaseDocument                 string
	VendorInfo                   string
	CustomerInfo                 string
	DeliveryNoteItems            string
}{
	ID:                           "delivery_note_view.id",
	BaseDocumentID:               "delivery_note_view.base_document_id",
	DeliveryNoteNumber:           "delivery_note_view.delivery_note_number",
	SalesOrderID:                 "delivery_note_view.sales_order_id",
	VendorID:                     "delivery_note_view.vendor_id",
	CustomerID:                   "delivery_note_view.customer_id",
	ShipToInformation:            "delivery_note_view.ship_to_information",
	ShipFromInformation:          "delivery_note_view.ship_from_information",
	BillToInformation:            "delivery_note_view.bill_to_information",
	ShippingDate:                 "delivery_note_view.shipping_date",
	ShippingPersonnelInformation: "delivery_note_view.shipping_personnel_information",
	ShippingStatus:               "delivery_note_view.shipping_status",
	ReceivedBy:                   "delivery_note_view.received_by",
	OverallGoodsCondition:        "delivery_note_view.overall_goods_condition",
	CreatedAt:                    "delivery_note_view.created_at",
	UpdatedAt:                    "delivery_note_view.updated_at",
	DeletedAt:                    "delivery_note_view.deleted_at",
	BaseDocument:                 "delivery_note_view.base_document",
	VendorInfo:                   "delivery_note_view.vendor_info",
	CustomerInfo:                 "delivery_note_view.customer_info",
	DeliveryNoteItems:            "delivery_note_view.delivery_note_items",
}

// Generated where

type whereHelperNullShippingStatus struct{ field string }

func (w whereHelperNullShippingStatus) EQ(x NullShippingStatus) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelperNullShippingStatus) NEQ(x NullShippingStatus) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelperNullShippingStatus) LT(x NullShippingStatus) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelperNullShippingStatus) LTE(x NullShippingStatus) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelperNullShippingStatus) GT(x NullShippingStatus) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelperNullShippingStatus) GTE(x NullShippingStatus) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}
func (w whereHelperNullShippingStatus) IN(slice []NullShippingStatus) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelperNullShippingStatus) NIN(slice []NullShippingStatus) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

func (w whereHelperNullShippingStatus) IsNull() qm.QueryMod { return qmhelper.WhereIsNull(w.field) }
func (w whereHelperNullShippingStatus) IsNotNull() qm.QueryMod {
	return qmhelper.WhereIsNotNull(w.field)
}

var DeliveryNoteViewWhere = struct {
	ID                           whereHelpernull_Int
	BaseDocumentID               whereHelpernull_Int
	DeliveryNoteNumber           whereHelpernull_String
	SalesOrderID                 whereHelpernull_Int
	VendorID                     whereHelpernull_Int
	CustomerID                   whereHelpernull_Int
	ShipToInformation            whereHelpernull_JSON
	ShipFromInformation          whereHelpernull_JSON
	BillToInformation            whereHelpernull_JSON
	ShippingDate                 whereHelpernull_Time
	ShippingPersonnelInformation whereHelpernull_JSON
	ShippingStatus               whereHelperNullShippingStatus
	ReceivedBy                   whereHelpernull_JSON
	OverallGoodsCondition        whereHelpernull_String
	CreatedAt                    whereHelpernull_Time
	UpdatedAt                    whereHelpernull_Time
	DeletedAt                    whereHelpernull_Time
	BaseDocument                 whereHelpernull_JSON
	VendorInfo                   whereHelpernull_JSON
	CustomerInfo                 whereHelpernull_JSON
	DeliveryNoteItems            whereHelpernull_JSON
}{
	ID:                           whereHelpernull_Int{field: "\"sale\".\"delivery_note_view\".\"id\""},
	BaseDocumentID:               whereHelpernull_Int{field: "\"sale\".\"delivery_note_view\".\"base_document_id\""},
	DeliveryNoteNumber:           whereHelpernull_String{field: "\"sale\".\"delivery_note_view\".\"delivery_note_number\""},
	SalesOrderID:                 whereHelpernull_Int{field: "\"sale\".\"delivery_note_view\".\"sales_order_id\""},
	VendorID:                     whereHelpernull_Int{field: "\"sale\".\"delivery_note_view\".\"vendor_id\""},
	CustomerID:                   whereHelpernull_Int{field: "\"sale\".\"delivery_note_view\".\"customer_id\""},
	ShipToInformation:            whereHelpernull_JSON{field: "\"sale\".\"delivery_note_view\".\"ship_to_information\""},
	ShipFromInformation:          whereHelpernull_JSON{field: "\"sale\".\"delivery_note_view\".\"ship_from_information\""},
	BillToInformation:            whereHelpernull_JSON{field: "\"sale\".\"delivery_note_view\".\"bill_to_information\""},
	ShippingDate:                 whereHelpernull_Time{field: "\"sale\".\"delivery_note_view\".\"shipping_date\""},
	ShippingPersonnelInformation: whereHelpernull_JSON{field: "\"sale\".\"delivery_note_view\".\"shipping_personnel_information\""},
	ShippingStatus:               whereHelperNullShippingStatus{field: "\"sale\".\"delivery_note_view\".\"shipping_status\""},
	ReceivedBy:                   whereHelpernull_JSON{field: "\"sale\".\"delivery_note_view\".\"received_by\""},
	OverallGoodsCondition:        whereHelpernull_String{field: "\"sale\".\"delivery_note_view\".\"overall_goods_condition\""},
	CreatedAt:                    whereHelpernull_Time{field: "\"sale\".\"delivery_note_view\".\"created_at\""},
	UpdatedAt:                    whereHelpernull_Time{field: "\"sale\".\"delivery_note_view\".\"updated_at\""},
	DeletedAt:                    whereHelpernull_Time{field: "\"sale\".\"delivery_note_view\".\"deleted_at\""},
	BaseDocument:                 whereHelpernull_JSON{field: "\"sale\".\"delivery_note_view\".\"base_document\""},
	VendorInfo:                   whereHelpernull_JSON{field: "\"sale\".\"delivery_note_view\".\"vendor_info\""},
	CustomerInfo:                 whereHelpernull_JSON{field: "\"sale\".\"delivery_note_view\".\"customer_info\""},
	DeliveryNoteItems:            whereHelpernull_JSON{field: "\"sale\".\"delivery_note_view\".\"delivery_note_items\""},
}

var (
	deliveryNoteViewAllColumns            = []string{"id", "base_document_id", "delivery_note_number", "sales_order_id", "vendor_id", "customer_id", "ship_to_information", "ship_from_information", "bill_to_information", "shipping_date", "shipping_personnel_information", "shipping_status", "received_by", "overall_goods_condition", "created_at", "updated_at", "deleted_at", "base_document", "vendor_info", "customer_info", "delivery_note_items"}
	deliveryNoteViewColumnsWithoutDefault = []string{}
	deliveryNoteViewColumnsWithDefault    = []string{"id", "base_document_id", "delivery_note_number", "sales_order_id", "vendor_id", "customer_id", "ship_to_information", "ship_from_information", "bill_to_information", "shipping_date", "shipping_personnel_information", "shipping_status", "received_by", "overall_goods_condition", "created_at", "updated_at", "deleted_at", "base_document", "vendor_info", "customer_info", "delivery_note_items"}
	deliveryNoteViewPrimaryKeyColumns     = []string{}
	deliveryNoteViewGeneratedColumns      = []string{}
)

type (
	// DeliveryNoteViewSlice is an alias for a slice of pointers to DeliveryNoteView.
	// This should almost always be used instead of []DeliveryNoteView.
	DeliveryNoteViewSlice []*DeliveryNoteView
	// DeliveryNoteViewHook is the signature for custom DeliveryNoteView hook methods
	DeliveryNoteViewHook func(context.Context, boil.ContextExecutor, *DeliveryNoteView) error

	deliveryNoteViewQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	deliveryNoteViewType           = reflect.TypeOf(&DeliveryNoteView{})
	deliveryNoteViewMapping        = queries.MakeStructMapping(deliveryNoteViewType)
	deliveryNoteViewInsertCacheMut sync.RWMutex
	deliveryNoteViewInsertCache    = make(map[string]insertCache)
	deliveryNoteViewUpdateCacheMut sync.RWMutex
	deliveryNoteViewUpdateCache    = make(map[string]updateCache)
	deliveryNoteViewUpsertCacheMut sync.RWMutex
	deliveryNoteViewUpsertCache    = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
	// These are used in some views
	_ = fmt.Sprintln("")
	_ = reflect.Int
	_ = strings.Builder{}
	_ = sync.Mutex{}
	_ = strmangle.Plural("")
	_ = strconv.IntSize
)

var deliveryNoteViewAfterSelectMu sync.Mutex
var deliveryNoteViewAfterSelectHooks []DeliveryNoteViewHook

var deliveryNoteViewBeforeInsertMu sync.Mutex
var deliveryNoteViewBeforeInsertHooks []DeliveryNoteViewHook
var deliveryNoteViewAfterInsertMu sync.Mutex
var deliveryNoteViewAfterInsertHooks []DeliveryNoteViewHook

var deliveryNoteViewBeforeUpsertMu sync.Mutex
var deliveryNoteViewBeforeUpsertHooks []DeliveryNoteViewHook
var deliveryNoteViewAfterUpsertMu sync.Mutex
var deliveryNoteViewAfterUpsertHooks []DeliveryNoteViewHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *DeliveryNoteView) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range deliveryNoteViewAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *DeliveryNoteView) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range deliveryNoteViewBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *DeliveryNoteView) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range deliveryNoteViewAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *DeliveryNoteView) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range deliveryNoteViewBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *DeliveryNoteView) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range deliveryNoteViewAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddDeliveryNoteViewHook registers your hook function for all future operations.
func AddDeliveryNoteViewHook(hookPoint boil.HookPoint, deliveryNoteViewHook DeliveryNoteViewHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		deliveryNoteViewAfterSelectMu.Lock()
		deliveryNoteViewAfterSelectHooks = append(deliveryNoteViewAfterSelectHooks, deliveryNoteViewHook)
		deliveryNoteViewAfterSelectMu.Unlock()
	case boil.BeforeInsertHook:
		deliveryNoteViewBeforeInsertMu.Lock()
		deliveryNoteViewBeforeInsertHooks = append(deliveryNoteViewBeforeInsertHooks, deliveryNoteViewHook)
		deliveryNoteViewBeforeInsertMu.Unlock()
	case boil.AfterInsertHook:
		deliveryNoteViewAfterInsertMu.Lock()
		deliveryNoteViewAfterInsertHooks = append(deliveryNoteViewAfterInsertHooks, deliveryNoteViewHook)
		deliveryNoteViewAfterInsertMu.Unlock()
	case boil.BeforeUpsertHook:
		deliveryNoteViewBeforeUpsertMu.Lock()
		deliveryNoteViewBeforeUpsertHooks = append(deliveryNoteViewBeforeUpsertHooks, deliveryNoteViewHook)
		deliveryNoteViewBeforeUpsertMu.Unlock()
	case boil.AfterUpsertHook:
		deliveryNoteViewAfterUpsertMu.Lock()
		deliveryNoteViewAfterUpsertHooks = append(deliveryNoteViewAfterUpsertHooks, deliveryNoteViewHook)
		deliveryNoteViewAfterUpsertMu.Unlock()
	}
}

// One returns a single deliveryNoteView record from the query.
func (q deliveryNoteViewQuery) One(ctx context.Context, exec boil.ContextExecutor) (*DeliveryNoteView, error) {
	o := &DeliveryNoteView{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "sale: failed to execute a one query for delivery_note_view")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all DeliveryNoteView records from the query.
func (q deliveryNoteViewQuery) All(ctx context.Context, exec boil.ContextExecutor) (DeliveryNoteViewSlice, error) {
	var o []*DeliveryNoteView

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "sale: failed to assign all query results to DeliveryNoteView slice")
	}

	if len(deliveryNoteViewAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all DeliveryNoteView records in the query.
func (q deliveryNoteViewQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "sale: failed to count delivery_note_view rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q deliveryNoteViewQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "sale: failed to check if delivery_note_view exists")
	}

	return count > 0, nil
}

// DeliveryNoteViews retrieves all the records using an executor.
func DeliveryNoteViews(mods ...qm.QueryMod) deliveryNoteViewQuery {
	mods = append(mods, qm.From("\"sale\".\"delivery_note_view\""))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"\"sale\".\"delivery_note_view\".*"})
	}

	return deliveryNoteViewQuery{q}
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *DeliveryNoteView) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("sale: no delivery_note_view provided for insertion")
	}

	var err error
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if queries.MustTime(o.CreatedAt).IsZero() {
			queries.SetScanner(&o.CreatedAt, currTime)
		}
		if queries.MustTime(o.UpdatedAt).IsZero() {
			queries.SetScanner(&o.UpdatedAt, currTime)
		}
	}

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(deliveryNoteViewColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	deliveryNoteViewInsertCacheMut.RLock()
	cache, cached := deliveryNoteViewInsertCache[key]
	deliveryNoteViewInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			deliveryNoteViewAllColumns,
			deliveryNoteViewColumnsWithDefault,
			deliveryNoteViewColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(deliveryNoteViewType, deliveryNoteViewMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(deliveryNoteViewType, deliveryNoteViewMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"sale\".\"delivery_note_view\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"sale\".\"delivery_note_view\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "sale: unable to insert into delivery_note_view")
	}

	if !cached {
		deliveryNoteViewInsertCacheMut.Lock()
		deliveryNoteViewInsertCache[key] = cache
		deliveryNoteViewInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *DeliveryNoteView) Upsert(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns, opts ...UpsertOptionFunc) error {
	if o == nil {
		return errors.New("sale: no delivery_note_view provided for upsert")
	}
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if queries.MustTime(o.CreatedAt).IsZero() {
			queries.SetScanner(&o.CreatedAt, currTime)
		}
		queries.SetScanner(&o.UpdatedAt, currTime)
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(deliveryNoteViewColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	deliveryNoteViewUpsertCacheMut.RLock()
	cache, cached := deliveryNoteViewUpsertCache[key]
	deliveryNoteViewUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, _ := insertColumns.InsertColumnSet(
			deliveryNoteViewAllColumns,
			deliveryNoteViewColumnsWithDefault,
			deliveryNoteViewColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			deliveryNoteViewAllColumns,
			deliveryNoteViewPrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("sale: unable to upsert delivery_note_view, could not build update column list")
		}

		ret := strmangle.SetComplement(deliveryNoteViewAllColumns, strmangle.SetIntersect(insert, update))

		conflict := conflictColumns
		if len(conflict) == 0 && updateOnConflict && len(update) != 0 {
			if len(deliveryNoteViewPrimaryKeyColumns) == 0 {
				return errors.New("sale: unable to upsert delivery_note_view, could not build conflict column list")
			}

			conflict = make([]string, len(deliveryNoteViewPrimaryKeyColumns))
			copy(conflict, deliveryNoteViewPrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"sale\".\"delivery_note_view\"", updateOnConflict, ret, update, conflict, insert, opts...)

		cache.valueMapping, err = queries.BindMapping(deliveryNoteViewType, deliveryNoteViewMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(deliveryNoteViewType, deliveryNoteViewMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
		if errors.Is(err, sql.ErrNoRows) {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "sale: unable to upsert delivery_note_view")
	}

	if !cached {
		deliveryNoteViewUpsertCacheMut.Lock()
		deliveryNoteViewUpsertCache[key] = cache
		deliveryNoteViewUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}
