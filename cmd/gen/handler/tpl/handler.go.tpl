// Code generated by MVRP Codegen Util. DO NOT EDIT.

package {{ .Package }}

import (
	"context"
	"encoding/json"
	"fmt"
	"mvrp/domain/dto"
	"mvrp/domain/service/{{ .Package }}"
	"mvrp/errors"
	"mvrp/htresp"
	"net/http"
	"strconv"

	"github.com/go-chi/chi/v5"
)

const {{ .Name }}Key contextKey = "{{ .Name }}"

func {{ .Name }}Context(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		var resp *{{ .Package }}.Get{{ .Name }}Response
		if idStr := chi.URLParam(r, "id"); idStr != "" {
			id, err := strconv.Atoi(idStr)
			if err != nil {
				htresp.RespondWithError(w, http.StatusBadRequest,
					errors.WrapError(errors.ErrTypeConversion, "ID must be an integer"),
					"Failed to convert ID to integer")
				return
			}
			svc := {{ .Package }}.New{{ .Package | ToPascalCase }}Service()
			req := svc.NewGet{{ .Name }}Request(r.Context(), id)
			resp, err = svc.Get{{ .Name }}(req)
			if err != nil {
				htresp.RespondWithError(w, http.StatusInternalServerError,
					errors.WrapError(errors.ErrTypeService, err.Error()),
					"Failed to get {{ .Name }} for context: " + err.Error())
				return
			}
		} else {
			htresp.RespondWithError(w, http.StatusBadRequest,
				errors.WrapError(errors.ErrTypeBadRequest, "ID is required"),
				"Failed to get {{ .Name }}")
			return
		}
		ctx := context.WithValue(r.Context(), {{ .Name }}Key, resp)
		next.ServeHTTP(w, r.WithContext(ctx))
	})
}

{{ $isView := .IsView }}
{{ range .Routes }}
func {{ .Handler }}(w http.ResponseWriter, r *http.Request) {
	{{ if eq .Type "search" }}
	{{- if not $isView }}
	var dto *dto.Search{{ $.Name }}DTO
	{{- else }}
	var dto *dto.Search{{ $.Name | GetCleanName }}DTO
	{{- end }}
	err := json.NewDecoder(r.Body).Decode(&dto)
	if err != nil {
		htresp.RespondWithError(w, http.StatusBadRequest, err, "Failed to decode request body: " + err.Error())
		return
	}
	svc := {{ $.Package }}.New{{ $.Package | ToPascalCase }}Service()
	req := svc.NewSearch{{ $.Name }}Request(r.Context(), *dto)
	resp, err := svc.Search{{ $.Name }}(req)
	if err != nil {
		htresp.RespondWithError(w, http.StatusInternalServerError,
			errors.WrapError(errors.ErrTypeService, err.Error()),
			"Failed to search {{ $.Name }}: " + err.Error())
		return
	}
	htresp.RespondWithJSON(w, http.StatusOK, resp, "{{ $.Name }} search successful")

	{{ else if eq .Type "get" }}value, ok := r.Context().Value({{ $.Name }}Key).(*{{ $.Package }}.Get{{ $.Name }}Response)
	if !ok {
		htresp.RespondWithError(w, http.StatusInternalServerError,
			errors.WrapError(errors.ErrTypeAssertion,
				fmt.Sprintf("Incorrect response format, should be %T", r.Context().Value({{ $.Name }}Key))),
			"Failed to get {{ $.Name }}")
		return
	}
	htresp.RespondWithJSON(w, http.StatusOK, value, "{{ $.Name }} retrieved successfully")

	{{ else if eq .Type "create" }}var data *dto.Create{{ $.Name }}DTO
	err := json.NewDecoder(r.Body).Decode(&data)
	if err != nil {
		htresp.RespondWithError(w, http.StatusBadRequest,
			errors.WrapError(errors.ErrTypeDecoding, err.Error()),
			"Failed to decode request body: " + err.Error())
		return
	}
	svc := {{ $.Package }}.New{{ $.Package | ToPascalCase }}Service()
	req := svc.NewCreate{{ $.Name }}Request(r.Context(), *data)
	resp, err := svc.Create{{ $.Name }}(req)
	if err != nil {
		htresp.RespondWithError(w, http.StatusInternalServerError,
			errors.WrapError(errors.ErrTypeService, err.Error()),
			"Failed to create {{ $.Name }}: " + err.Error())
		return
	}
	htresp.RespondWithJSON(w, http.StatusCreated, resp, "{{ $.Name }} created successfully")

	{{ else if eq .Type "update" }}_, ok := r.Context().Value({{ $.Name }}Key).(*{{ $.Package }}.Get{{ $.Name }}Response)
	if !ok {
		htresp.RespondWithError(w, http.StatusInternalServerError,
			errors.WrapError(errors.ErrTypeAssertion,
				fmt.Sprintf("Incorrect response format, should be %T", r.Context().Value({{ $.Name }}Key))),
			"Failed to get {{ $.Name }}")
		return
	}
	var data *dto.Update{{ $.Name }}DTO
	err := json.NewDecoder(r.Body).Decode(&data)
	if err != nil {
		htresp.RespondWithError(w, http.StatusBadRequest,
			errors.WrapError(errors.ErrTypeDecoding, err.Error()),
			"Failed to decode request body: " + err.Error())
		return
	}
	svc := {{ $.Package }}.New{{ $.Package | ToPascalCase }}Service()
	req := svc.NewUpdate{{ $.Name }}Request(r.Context(), *data)
	resp, err := svc.Update{{ $.Name }}(req)
	if err != nil {
		htresp.RespondWithError(w, http.StatusInternalServerError,
			errors.WrapError(errors.ErrTypeService, err.Error()),
			"Failed to update {{ $.Name }}: " + err.Error())
		return
	}
	htresp.RespondWithJSON(w, http.StatusOK, resp, "{{ $.Name }} updated successfully")

	{{ else if eq .Type "delete" }}v, ok := r.Context().Value({{ $.Name }}Key).(*{{ $.Package }}.Get{{ $.Name }}Response)
	if !ok {
		htresp.RespondWithError(w, http.StatusInternalServerError,
			errors.WrapError(errors.ErrTypeAssertion,
				fmt.Sprintf("Incorrect response format, should be %T", r.Context().Value({{ $.Name }}Key))),
			"Failed to get {{ $.Name }}")
		return
	}
	svc := {{ $.Package }}.New{{ $.Package | ToPascalCase }}Service()
	req := svc.NewDelete{{ $.Name }}Request(r.Context(), v.Payload.ID)
	resp, err := svc.Delete{{ $.Name }}(req)
	if err != nil {
		htresp.RespondWithError(w, http.StatusInternalServerError,
			errors.WrapError(errors.ErrTypeService, err.Error()),
			"Failed to delete {{ $.Name }}: " + err.Error())
		return
	}
	htresp.RespondWithJSON(w, http.StatusOK, resp, "{{ $.Name }} deleted successfully")

	{{ else if eq .Type "list" }}svc := {{ $.Package }}.New{{ $.Package | ToPascalCase }}Service()
	req := svc.NewList{{ $.Name }}Request(r.Context())
	resp, err := svc.List{{ $.Name }}(req)
	if err != nil {
		htresp.RespondWithError(w, http.StatusInternalServerError,
			errors.WrapError(errors.ErrTypeService, err.Error()),
			"Failed to list {{ $.Name }}: " + err.Error())
		return
	}
	htresp.RespondWithJSON(w, http.StatusOK, resp, "{{ $.Name }} listed successfully")
	{{ end }}
}
{{ end }}
